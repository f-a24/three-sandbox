{"version":3,"file":"3.c8f2cf5d170200fd0583.bundle.js","sources":["webpack:///./node_modules/three/examples/js/renderers/WebGLDeferredRenderer.js"],"sourcesContent":["/*** IMPORTS FROM imports-loader ***/\nvar THREE = require(\"three\");\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author MPanknin / http://www.redplant.de/\n * @author takahiro / https://github.com/takahirox\n *\n * WebGLDeferredRenderer supports two types of Deferred Renderings.\n * One is Classic Deferred Rendering and the other one is\n * Light Pre-Pass (Deferred Lighting).\n * Classic Deferred Rendering is default. You can use Light Pre-Pass\n * by calling .enableLightPrePass( true ) method.\n *\n * Dependencies\n *  - THREE.CopyShader\n *  - THREE.RenderPass\n *  - THREE.ShaderPass\n *  - THREE.EffectComposer\n *  - THREE.FXAAShader\n *\n * TODO\n *  - reuse existing glsl\n *  - shadow\n *  - optimization\n *  - MRT (when it's available on Three.js)\n *  - AmbientLight\n *  - HemisphereLight\n *  - PointLight (distance < 0)\n *  - morphNormals\n *  - BumpMap\n *  - ToneMap\n *  - envMap\n *  - wrapAround\n *  - addEffect\n */\n\nTHREE.WebGLDeferredRenderer = function ( parameters ) {\n\n\tparameters = parameters || {};\n\n\t// private properties\n\n\tvar _this = this;\n\n\tvar _context;\n\tvar _state;\n\n\tvar _width, _height;\n\n\t// for Classic Deferred Rendering\n\tvar _compColor;\n\tvar _passColor, _passForward, _passCopy;\n\n\t// for Light Pre-Pass\n\tvar _compReconstruction;\n\tvar _passReconstruction;\n\n\t// for Common\n\tvar _compNormalDepth, _compLight, _compFinal;\n\tvar _passNormalDepth, _passLight, _passLightFullscreen, _passFinal, _passFXAA;\n\n\tvar _depthTexture;\n\n\tvar _currentCamera;\n\n\tvar _lightScene, _lightFullscreenScene;\n\n\tvar _antialias = false;\n\tvar _hasTransparentObject = false;\n\tvar _lightPrePass = false;\n\tvar _cacheKeepAlive = false;\n\n\tvar _tmpMaterial = new THREE.ShaderMaterial( { visible: false } );\n\tvar _tmpVector3 = new THREE.Vector3();\n\n\t// scene/material/light cache for deferred rendering.\n\t// save them at the creation and release\n\t// if they're unused removeThresholdCount frames\n\t// unless _cacheKeepAlive is true.\n\n\t// scene.uuid -> lightScene, lightFullscreenScene\n\tvar _lightScenesCache = {};\n\tvar _lightFullscreenScenesCache = {};\n\n\t// object.material.uuid -> deferredMaterial or\n\t// object.material[ n ].uuid -> deferredMaterial\n\tvar _normalDepthMaterialsCache = {};\n\tvar _normalDepthShininessMaterialsCache = {};\n\tvar _colorMaterialsCache = {};\n\tvar _reconstructionMaterialsCache = {};\n\n\t// originalLight.uuid -> deferredLight\n\tvar _deferredLightsCache = {};\n\n\t// deferredLight.uuid -> deferredLightMaterial\n\tvar _classicDeferredLightMaterialsCache = {};\n\tvar _lightPrePassMaterialsCache = {};\n\n\tvar _removeThresholdCount = 60;\n\n\t// deferredMaterials.uuid -> object.material or\n\t// deferredMaterials.uuid -> object.material[ n ]\n\t// save before render and release after render.\n\tvar _originalMaterialsTable = {};\n\n\t// object.uuid -> originalOnBeforeRender\n\t// save before render and release after render.\n\tvar _originalOnBeforeRendersTable = {};\n\n\t// object.material.uuid -> object.material.visible or\n\t// object.material[ i ].uuid -> object.material[ i ].visible or\n\t// save before render and release after render.\n\tvar _originalVisibleTable = {};\n\n\t// external properties\n\n\tthis.renderer = undefined;\n\tthis.domElement = undefined;\n\n\tthis.forwardRendering = false; // for debug\n\n\t// private methods\n\n\tfunction init( parameters ) {\n\n\t\t_this.renderer = parameters.renderer !== undefined ? parameters.renderer : new THREE.WebGLRenderer();\n\t\t_this.domElement = _this.renderer.domElement;\n\n\t\t_context = _this.renderer.context;\n\t\t_state = _this.renderer.state;\n\n\t\t_width = parameters.width !== undefined ? parameters.width : _this.renderer.getSize( new THREE.Vector2() ).width;\n\t\t_height = parameters.height !== undefined ? parameters.height : _this.renderer.getSize( new THREE.Vector2() ).height;\n\n\t\tvar antialias = parameters.antialias !== undefined ? parameters.antialias : false;\n\n\t\tif ( parameters.cacheKeepAlive !== undefined ) _cacheKeepAlive = parameters.cacheKeepAlive;\n\n\t\tinitDepthTexture();\n\n\t\tinitPassNormalDepth();\n\t\tinitPassColor();\n\t\tinitPassLight();\n\t\tinitPassReconstruction();\n\t\tinitPassFinal();\n\n\t\t_this.setSize( _width, _height );\n\t\t_this.setAntialias( antialias );\n\t\t_this.enableLightPrePass( false );\n\n\t}\n\n\tfunction initDepthTexture() {\n\n\t\t_depthTexture = new THREE.DepthTexture(\n\t\t\t_width,\n\t\t\t_height,\n\t\t\tTHREE.UnsignedInt248Type,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tTHREE.DepthStencilFormat\n\t\t);\n\n\t}\n\n\tfunction initPassNormalDepth() {\n\n\t\t_passNormalDepth = new THREE.RenderPass();\n\t\t_passNormalDepth.clear = true;\n\n\t\tvar rt = new THREE.WebGLRenderTarget( _width, _height, {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: THREE.FloatType,\n\t\t\tstencilBuffer: true,\n\t\t\tdepthTexture: _depthTexture\n\t\t} );\n\n\t\trt.texture.generateMipamps = false;\n\n\t\t_compNormalDepth = new THREE.EffectComposer( _this.renderer, rt );\n\t\t_compNormalDepth.renderToScreen = false;\n\t\t_compNormalDepth.addPass( _passNormalDepth );\n\n\t}\n\n\tfunction initPassColor() {\n\n\t\t_passColor = new THREE.RenderPass();\n\t\t_passColor.clear = true;\n\n\t\tvar rt = new THREE.WebGLRenderTarget( _width, _height, {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: THREE.FloatType,\n\t\t\tdepthTexture: _depthTexture\n\t\t} );\n\n\t\trt.texture.generateMipamps = false;\n\n\t\t_compColor = new THREE.EffectComposer( _this.renderer, rt );\n\t\t_compColor.renderToScreen = false;\n\t\t_compColor.addPass( _passColor );\n\n\t}\n\n\tfunction initPassLight() {\n\n\t\t_passLightFullscreen = new THREE.RenderPass();\n\t\t_passLightFullscreen.clear = true;\n\t\t_passLightFullscreen.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\t\t_passLight = new THREE.RenderPass();\n\t\t_passLight.clear = false;\n\n\t\tvar rt = new THREE.WebGLRenderTarget( _width, _height, {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: THREE.FloatType,\n\t\t\tdepthTexture: _depthTexture\n\t\t} );\n\n\t\trt.texture.generateMipamps = false;\n\n\t\t_compLight = new THREE.EffectComposer( _this.renderer, rt );\n\t\t_compLight.renderToScreen = false;\n\t\t_compLight.addPass( _passLightFullscreen );\n\t\t_compLight.addPass( _passLight );\n\n\t}\n\n\tfunction initPassReconstruction() {\n\n\t\t_passReconstruction = new THREE.RenderPass();\n\t\t_passReconstruction.clear = true;\n\n\t\tvar rt = new THREE.WebGLRenderTarget( _width, _height, {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: THREE.FloatType,\n\t\t\tdepthTexture: _depthTexture\n\t\t} );\n\n\t\trt.texture.generateMipamps = false;\n\n\t\t_compReconstruction = new THREE.EffectComposer( _this.renderer, rt );\n\t\t_compReconstruction.renderToScreen = false;\n\t\t_compReconstruction.addPass( _passReconstruction );\n\n\t}\n\n\tfunction initPassFinal() {\n\n\t\t_passFinal = new THREE.ShaderPass( THREE.ShaderDeferred[ 'final' ] );\n\t\t_passFinal.clear = true;\n\t\t_passFinal.uniforms.samplerResult.value = _compLight.renderTarget2.texture;\n\t\t_passFinal.material.blending = THREE.NoBlending;\n\t\t_passFinal.material.depthWrite = false;\n\t\t_passFinal.material.depthTest = false;\n\n\t\t_passForward = new THREE.RenderPass();\n\t\t_passForward.clear = false;\n\n\t\t_passCopy = new THREE.ShaderPass( THREE.CopyShader );\n\n\t\t_passFXAA = new THREE.ShaderPass( THREE.FXAAShader );\n\n\t\tvar rt = new THREE.WebGLRenderTarget( _width, _height, {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\ttype: THREE.UnsignedByteType,\n\t\t\tdepthTexture: _depthTexture\n\t\t} );\n\n\t\trt.texture.generateMipamps = false;\n\n\t\t_compFinal = new THREE.EffectComposer( _this.renderer, rt );\n\t\t_compFinal.addPass( _passFinal );\n\t\t_compFinal.addPass( _passForward );\n\t\t_compFinal.addPass( _passCopy );\n\t\t_compFinal.addPass( _passFXAA );\n\n\t}\n\n\tfunction initLightScene( scene ) {\n\n\t\tvar lightSceneData = _lightScenesCache[ scene.uuid ];\n\t\tvar lightFullscreenSceneData = _lightFullscreenScenesCache[ scene.uuid ];\n\n\t\tif ( lightSceneData === undefined ) {\n\n\t\t\tvar s = new THREE.Scene();\n\t\t\ts.userData.lights = {};\n\n\t\t\tlightSceneData = createCacheData();\n\t\t\tlightSceneData.scene = s;\n\n\t\t\t_lightScenesCache[ scene.uuid ] = lightSceneData;\n\n\t\t}\n\n\t\tif ( lightFullscreenSceneData === undefined ) {\n\n\t\t\tvar s = new THREE.Scene();\n\t\t\ts.userData.lights = {};\n\n\t\t\tvar emissiveLight = createDeferredEmissiveLight();\n\n\t\t\ts.userData.emissiveLight = emissiveLight;\n\t\t\ts.add( emissiveLight );\n\n\t\t\tlightFullscreenSceneData = createCacheData();\n\t\t\tlightFullscreenSceneData.scene = s;\n\n\t\t\t_lightFullscreenScenesCache[ scene.uuid ] = lightFullscreenSceneData;\n\n\t\t}\n\n\t\tlightSceneData.used = true;\n\t\tlightFullscreenSceneData.used = true;\n\n\t\tvar lightScene = lightSceneData.scene;\n\t\tvar lightFullscreenScene = lightFullscreenSceneData.scene;\n\n\t\t// emissiveLight is only for Classic Deferred Rendering\n\t\tlightFullscreenScene.userData.emissiveLight.visible = ! _lightPrePass;\n\n\t\t_lightScene = lightScene;\n\t\t_lightFullscreenScene = lightFullscreenScene;\n\n\t}\n\n\tfunction getMaterialFromCacheOrCreate( originalMaterial, cache, createFunc, updateFunc ) {\n\n\t\tvar data = cache[ originalMaterial.uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = createCacheData();\n\t\t\tdata.material = createFunc( originalMaterial );\n\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t}\n\n\t\tdata.used = true;\n\n\t\tupdateFunc( data.material, originalMaterial );\n\n\t\t_originalMaterialsTable[ data.material.uuid ] = originalMaterial;\n\n\t\treturn data.material;\n\n\t}\n\n\tfunction overrideMaterialAndOnBeforeRender( object, getMaterialFunc, onBeforeRender ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = getMaterialFunc( object.material[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = getMaterialFunc( object.material );\n\n\t\t}\n\n\t\tobject.onBeforeRender = onBeforeRender;\n\n\t}\n\n\tfunction restoreOriginalMaterial( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = _originalMaterialsTable[ object.material[ i ].uuid ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = _originalMaterialsTable[ object.material.uuid ];\n\n\t\t}\n\n\t}\n\n\tfunction setMaterialNormalDepth( object ) {\n\n\t\toverrideMaterialAndOnBeforeRender( object, getNormalDepthMaterial, updateDeferredNormalDepthUniforms );\n\n\t}\n\n\tfunction getNormalDepthMaterial( originalMaterial ) {\n\n\t\treturn getMaterialFromCacheOrCreate(\n\t\t\toriginalMaterial,\n\t\t\t( _lightPrePass ) ? _normalDepthShininessMaterialsCache : _normalDepthMaterialsCache,\n\t\t\tcreateDeferredNormalDepthMaterial,\n\t\t\tupdateDeferredNormalDepthMaterial\n\t\t);\n\n\t}\n\n\tfunction createDeferredNormalDepthMaterial( originalMaterial ) {\n\n\t\tvar shader = ( _lightPrePass ) ? THREE.ShaderDeferred[ 'normalDepthShininess' ] : THREE.ShaderDeferred[ 'normalDepth' ];\n\n\t\treturn new THREE.ShaderMaterial( {\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t}\n\n\tfunction updateDeferredNormalDepthMaterial( material, originalMaterial ) {\n\n\t\tif ( originalMaterial.skinning !== undefined ) material.skinning = originalMaterial.skinning;\n\t\tif ( originalMaterial.morphTargets !== undefined ) material.morphTargets = originalMaterial.morphTargets;\n\n\t\tif ( originalMaterial.visible === true ) {\n\n\t\t\tmaterial.visible = ! originalMaterial.transparent;\n\n\t\t} else {\n\n\t\t\tmaterial.visible = false;\n\n\t\t}\n\n\t}\n\n\tfunction updateDeferredNormalDepthUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tif ( ! _lightPrePass ) return;\n\n\t\tvar originalMaterial = _originalMaterialsTable[ material.uuid ];\n\n\t\tif ( originalMaterial === undefined || originalMaterial.shininess === undefined ) return;\n\n\t\tmaterial.uniforms.shininess.value = originalMaterial.shininess;\n\n\t}\n\n\tfunction setMaterialColor( object ) {\n\n\t\toverrideMaterialAndOnBeforeRender( object, getColorMaterial, updateDeferredColorUniforms );\n\n\t}\n\n\tfunction getColorMaterial( originalMaterial ) {\n\n\t\treturn getMaterialFromCacheOrCreate(\n\t\t\toriginalMaterial,\n\t\t\t_colorMaterialsCache,\n\t\t\tcreateDeferredColorMaterial,\n\t\t\tupdateDeferredColorMaterial\n\t\t);\n\n\t}\n\n\tfunction createDeferredColorMaterial( originalMaterial ) {\n\n\t\tvar shader = THREE.ShaderDeferred[ 'color' ];\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tif ( originalMaterial.map !== undefined ) material.map = originalMaterial.map;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredColorMaterial( material, originalMaterial ) {\n\n\t\tif ( originalMaterial.map !== undefined ) material.map = originalMaterial.map;\n\t\tif ( originalMaterial.skinning !== undefined ) material.skinning = originalMaterial.skinning;\n\t\tif ( originalMaterial.morphTargets !== undefined ) material.morphTargets = originalMaterial.morphTargets;\n\n\t\tif ( originalMaterial.visible === true ) {\n\n\t\t\tmaterial.visible = ! originalMaterial.transparent;\n\n\t\t} else {\n\n\t\t\tmaterial.visible = false;\n\n\t\t}\n\n\t}\n\n\tfunction updateDeferredColorUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar originalMaterial = _originalMaterialsTable[ material.uuid ];\n\t\tvar uniforms = material.uniforms;\n\n\t\tvar diffuse, emissive;\n\n\t\tif ( originalMaterial.isMeshBasicMaterial === true ) {\n\n\t\t\temissive = originalMaterial.color;\n\n\t\t} else {\n\n\t\t\tdiffuse = originalMaterial.color;\n\t\t\temissive = originalMaterial.emissive;\n\n\t\t}\n\n\t\tvar specular = originalMaterial.specular;\n\t\tvar shininess = originalMaterial.shininess;\n\t\tvar map = originalMaterial.map;\n\n\t\tif ( diffuse !== undefined ) uniforms.diffuse.value.copy( diffuse );\n\t\tif ( emissive !== undefined ) uniforms.emissive.value.copy( emissive );\n\t\tif ( specular !== undefined ) uniforms.specular.value.copy( specular );\n\t\tif ( shininess !== undefined && uniforms.shininess !== undefined ) uniforms.shininess.value = shininess;\n\t\tif ( map !== undefined ) uniforms.map.value = map;\n\n\t}\n\n\tfunction setMaterialReconstruction( object ) {\n\n\t\toverrideMaterialAndOnBeforeRender( object, getReconstructionMaterial, updateDeferredReconstructionUniforms );\n\n\t}\n\n\tfunction getReconstructionMaterial( originalMaterial ) {\n\n\t\tif ( originalMaterial.transparent === true ) {\n\n\t\t\t_originalMaterialsTable[ originalMaterial.uuid ] = originalMaterial;\n\t\t\treturn originalMaterial;\n\n\t\t}\n\n\t\treturn getMaterialFromCacheOrCreate(\n\t\t\toriginalMaterial,\n\t\t\t_reconstructionMaterialsCache,\n\t\t\tcreateDeferredReconstructionMaterial,\n\t\t\tupdateDeferredReconstructionMaterial\n\t\t);\n\n\t}\n\n\tfunction createDeferredReconstructionMaterial( originalMaterial ) {\n\n\t\tvar shader = THREE.ShaderDeferred[ 'reconstruction' ];\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tif ( originalMaterial.map !== undefined ) material.map = originalMaterial.map;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredReconstructionMaterial( material, originalMaterial ) {\n\n\t\tupdateDeferredColorMaterial( material, originalMaterial );\n\n\t}\n\n\tfunction updateDeferredReconstructionUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\t// 'this' is object here because this method is set as object.onBefore()\n\t\t\tvar onBeforeRender = _originalOnBeforeRendersTable[ this.uuid ];\n\n\t\t\tif ( onBeforeRender ) {\n\n\t\t\t\tonBeforeRender.call( this, renderer, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tupdateDeferredColorUniforms( renderer, scene, camera, geometry, material, group );\n\n\t\tmaterial.uniforms.samplerLight.value = _compLight.renderTarget2.texture;\n\n\t}\n\n\tfunction setVisibleForForwardRendering( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tif ( _originalVisibleTable[ object.material[ i ].uuid ] === undefined ) {\n\n\t\t\t\t\t_originalVisibleTable[ object.material[ i ].uuid ] = object.material[ i ].visible;\n\t\t\t\t\tobject.material[ i ].visible = object.material[ i ].transparent && object.material[ i ].visible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( _originalVisibleTable[ object.material.uuid ] === undefined ) {\n\n\t\t\t\t_originalVisibleTable[ object.material.uuid ] = object.material.visible;\n\t\t\t\tobject.material.visible = object.material.transparent && object.material.visible;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction restoreVisible( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ].visible = _originalVisibleTable[ object.material[ i ].uuid ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material.visible = _originalVisibleTable[ object.material.uuid ];\n\n\t\t}\n\n\t}\n\n\tfunction createDeferredEmissiveLight() {\n\n\t\tvar shader = THREE.ShaderDeferred[ 'emissiveLight' ];\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.NoBlending,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tvar geometry = new THREE.PlaneBufferGeometry( 2, 2 );\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\tmesh.onBeforeRender = function ( renderer, scene, camera, geometry, material, group ) {\n\n\t\t\tmaterial.uniforms.samplerColor.value = _compColor.renderTarget2.texture;\n\n\t\t};\n\n\t\treturn mesh;\n\n\t}\n\n\tfunction createDeferredLight( originalLight ) {\n\n\t\tif ( originalLight.isPointLight ) {\n\n\t\t\treturn createDeferredPointLight( originalLight );\n\n\t\t} else if ( originalLight.isSpotLight ) {\n\n\t\t\treturn createDeferredSpotLight( originalLight );\n\n\t\t} else if ( originalLight.isDirectionalLight ) {\n\n\t\t\treturn createDeferredDirectionalLight( originalLight );\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction createDeferredLightMaterial( originalLight ) {\n\n\t\tif ( originalLight.isPointLight ) {\n\n\t\t\treturn createDeferredPointLightMaterial();\n\n\t\t} else if ( originalLight.isSpotLight ) {\n\n\t\t\treturn createDeferredSpotLightMaterial();\n\n\t\t} else if ( originalLight.isDirectionalLight ) {\n\n\t\t\treturn createDeferredDirectionalLightMaterial();\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction getDeferredLightMaterial( light ) {\n\n\t\tvar cache = ( _lightPrePass ) ? _lightPrePassMaterialsCache : _classicDeferredLightMaterialsCache;\n\n\t\tvar data = cache[ light.uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = createCacheData();\n\t\t\tdata.material = createDeferredLightMaterial( light.userData.originalLight );\n\t\t\tcache[ light.uuid ] = data;\n\n\t\t}\n\n\t\tdata.used = true;\n\n\t\treturn data.material;\n\n\t}\n\n\tfunction updateDeferredLight( light ) {\n\n\t\tvar originalLight = light.userData.originalLight;\n\n\t\tif ( originalLight.isPointLight ) {\n\n\t\t\tupdateDeferredPointLight( light );\n\n\t\t}\n\n\t}\n\n\tfunction createDeferredLightMesh( light, geometry ) {\n\n\t\tvar mesh = new THREE.Mesh( geometry, _tmpMaterial );\n\n\t\tmesh.userData.originalLight = light;\n\n\t\treturn mesh;\n\n\t}\n\n\tfunction createDeferredLightShaderMaterial( shader ) {\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tif ( _lightPrePass ) material.premultipliedAlpha = true;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredLightCommonUniforms( uniforms ) {\n\n\t\tif ( _lightPrePass ) {\n\n\t\t\tuniforms.samplerNormalDepthShininess.value = _compNormalDepth.renderTarget2.texture;\n\n\t\t} else {\n\n\t\t\tuniforms.samplerNormalDepth.value = _compNormalDepth.renderTarget2.texture;\n\t\t\tuniforms.samplerColor.value = _compColor.renderTarget2.texture;\n\n\t\t}\n\n\t}\n\n\tfunction createDeferredPointLight( light ) {\n\n\t\tvar mesh = createDeferredLightMesh( light, new THREE.SphereBufferGeometry( 1, 16, 8 ) );\n\t\tmesh.onBeforeRender = updateDeferredPointLightUniforms;\n\t\treturn mesh;\n\n\t}\n\n\t/*\n\t * optimization:\n\t * Renders PointLight only back face with stencil test.\n\t */\n\tfunction createDeferredPointLightMaterial() {\n\n\t\tvar shader = ( _lightPrePass ) ? THREE.ShaderDeferred[ 'pointLightPre' ] : THREE.ShaderDeferred[ 'pointLight' ];\n\n\t\tvar material = createDeferredLightShaderMaterial( shader );\n\n\t\tmaterial.side = THREE.BackSide;\n\t\tmaterial.depthFunc = THREE.GreaterEqualDepth;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredPointLight( light ) {\n\n\t\tvar originalLight = light.userData.originalLight;\n\t\tvar distance = originalLight.distance;\n\n\t\tif ( distance > 0 ) {\n\n\t\t\tlight.scale.set( 1, 1, 1 ).multiplyScalar( distance );\n\t\t\tlight.position.setFromMatrixPosition( originalLight.matrixWorld );\n\n\t\t}\n\n\t}\n\n\tfunction updateDeferredPointLightUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar light = this;\n\n\t\tvar originalLight = light.userData.originalLight;\n\t\tvar distance = originalLight.distance;\n\t\tvar uniforms = material.uniforms;\n\n\t\tuniforms.lightColor.value.copy( originalLight.color );\n\n\t\tif ( distance > 0 ) {\n\n\t\t\tuniforms.lightRadius.value = distance;\n\t\t\tuniforms.lightIntensity.value = originalLight.intensity;\n\t\t\tuniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );\n\n\t\t} else {\n\n\t\t\tuniforms.lightRadius.value = Infinity;\n\n\t\t}\n\n\t\tupdateDeferredLightCommonUniforms( uniforms );\n\n\t}\n\n\tfunction createDeferredSpotLight( light ) {\n\n\t\tvar mesh = createDeferredLightMesh( light, new THREE.PlaneBufferGeometry( 2, 2 ) );\n\t\tmesh.onBeforeRender = updateDeferredSpotLightUniforms;\n\t\treturn mesh;\n\n\t}\n\n\tfunction createDeferredSpotLightMaterial() {\n\n\t\tvar shader = ( _lightPrePass ) ? THREE.ShaderDeferred[ 'spotLightPre' ] : THREE.ShaderDeferred[ 'spotLight' ];\n\n\t\tvar material = createDeferredLightShaderMaterial( shader );\n\n\t\tmaterial.depthTest = false;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredSpotLightUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar light = this;\n\n\t\tvar originalLight = light.userData.originalLight;\n\t\tvar uniforms = light.material.uniforms;\n\n\t\tuniforms.lightAngle.value = originalLight.angle;\n\t\tuniforms.lightColor.value.copy( originalLight.color );\n\t\tuniforms.lightIntensity.value = originalLight.intensity;\n\t\tuniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );\n\n\t\tvar vec = uniforms.lightDirectionVS.value;\n\t\tvar vec2 = _tmpVector3;\n\n\t\tvec.setFromMatrixPosition( originalLight.matrixWorld );\n\t\tvec2.setFromMatrixPosition( originalLight.target.matrixWorld );\n\t\tvec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );\n\n\t\tupdateDeferredLightCommonUniforms( uniforms );\n\n\t}\n\n\tfunction createDeferredDirectionalLight( light ) {\n\n\t\tvar mesh = createDeferredLightMesh( light, new THREE.PlaneBufferGeometry( 2, 2 ) );\n\t\tmesh.onBeforeRender = updateDeferredDirectionalLightUniforms;\n\t\treturn mesh;\n\n\t}\n\n\tfunction createDeferredDirectionalLightMaterial() {\n\n\t\tvar shader = ( _lightPrePass ) ? THREE.ShaderDeferred[ 'directionalLightPre' ] : THREE.ShaderDeferred[ 'directionalLight' ];\n\n\t\tvar material = createDeferredLightShaderMaterial( shader );\n\n\t\tmaterial.depthTest = false;\n\n\t\treturn material;\n\n\t}\n\n\tfunction updateDeferredDirectionalLightUniforms( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar light = this;\n\n\t\tvar originalLight = light.userData.originalLight;\n\t\tvar uniforms = light.material.uniforms;\n\n\t\tuniforms.lightColor.value.copy( originalLight.color );\n\t\tuniforms.lightIntensity.value = originalLight.intensity;\n\n\t\tvar vec = uniforms.lightDirectionVS.value;\n\t\tvar vec2 = _tmpVector3;\n\n\t\tvec.setFromMatrixPosition( originalLight.matrixWorld );\n\t\tvec2.setFromMatrixPosition( originalLight.target.matrixWorld );\n\t\tvec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );\n\n\t\tupdateDeferredLightCommonUniforms( uniforms );\n\n\t}\n\n\tfunction saveOriginalOnBeforeRenderAndCheckTransparency( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\t_originalOnBeforeRendersTable[ object.uuid ] = object.onBeforeRender;\n\n\t\t// _hasTransparentObject is used only for Classic Deferred Rendering\n\t\tif ( _hasTransparentObject || _lightPrePass ) return;\n\n\t\tif ( ! object.visible ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tif ( object.material[ i ].visible === true && object.material[ i ].transparent === true ) {\n\n\t\t\t\t\t_hasTransparentObject = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.material.visible === true && object.material.transparent === true ) _hasTransparentObject = true;\n\n\t\t}\n\n\t}\n\n\tfunction restoreOriginalOnBeforeRender( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tobject.onBeforeRender = _originalOnBeforeRendersTable[ object.uuid ];\n\n\t}\n\n\tfunction addDeferredLightsToLightScene( object ) {\n\n\t\tif ( object.isLight !== true ) return;\n\n\t\tvar data = _deferredLightsCache[ object.uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = createCacheData();\n\t\t\tdata.light = createDeferredLight( object );\n\t\t\t_deferredLightsCache[ object.uuid ] = data;\n\n\t\t}\n\n\t\tdata.used = true;\n\n\t\tvar light = data.light;\n\n\t\tif ( light === null ) return;\n\n\t\tvar scene = ( object.isPointLight === true ) ? _lightScene : _lightFullscreenScene;\n\n\t\tvar lights = scene.userData.lights;\n\n\t\tif ( lights[ light.uuid ] === undefined ) {\n\n\t\t\tscene.add( light );\n\n\t\t\tlights[ light.uuid ] = {\n\t\t\t\tlight: light,\n\t\t\t\tfound: true\n\t\t\t};\n\n\t\t}\n\n\t\tlights[ light.uuid ].found = true;\n\n\t}\n\n\tfunction updateDeferredLightsInLightScene( scene ) {\n\n\t\tvar lights = scene.userData.lights;\n\t\tvar keys = Object.keys( lights );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tvar key = keys[ i ];\n\n\t\t\tif ( lights[ key ].found === false ) {\n\n\t\t\t\tscene.remove( lights[ key ].light );\n\t\t\t\tdelete lights[ key ];\n\n\t\t\t} else {\n\n\t\t\t\tvar light = lights[ key ].light;\n\t\t\t\tlight.material = getDeferredLightMaterial( light );\n\n\t\t\t\tupdateDeferredLight( light );\n\t\t\t\tlights[ key ].found = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateDeferredCommonUniforms( camera ) {\n\n\t\tvar uniforms = THREE.ShaderDeferredCommon[ 'commonUniforms' ];\n\n\t\tuniforms.viewWidth.value = _width;\n\t\tuniforms.viewHeight.value = _height;\n\n\t\tuniforms.matProjInverse.value.getInverse( camera.projectionMatrix );\n\n\t}\n\n\tfunction enableFinalPasses() {\n\n\t\tif ( _lightPrePass ) {\n\n\t\t\t_passForward.enabled = false;\n\t\t\t_passCopy.enabled = false;\n\n\t\t\tif ( _antialias ) {\n\n\t\t\t\t_passFXAA.enabled = true;\n\n\t\t\t} else {\n\n\t\t\t\t_passFXAA.enabled = false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( _hasTransparentObject ) {\n\n\t\t\t\tif ( _antialias ) {\n\n\t\t\t\t\t_passForward.enabled = true;\n\t\t\t\t\t_passCopy.enabled = false;\n\t\t\t\t\t_passFXAA.enabled = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_passForward.enabled = true;\n\t\t\t\t\t_passCopy.enabled = true;\n\t\t\t\t\t_passFXAA.enabled = false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( _antialias ) {\n\n\t\t\t\t\t_passForward.enabled = false;\n\t\t\t\t\t_passCopy.enabled = false;\n\t\t\t\t\t_passFXAA.enabled = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_passForward.enabled = false;\n\t\t\t\t\t_passCopy.enabled = false;\n\t\t\t\t\t_passFXAA.enabled = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createCacheData() {\n\n\t\treturn {\n\t\t\tused: true,\n\t\t\tkeepAlive: _cacheKeepAlive,\n\t\t\tcount: 0\n\t\t};\n\n\t}\n\n\tfunction cleanupCache( cache ) {\n\n\t\tvar keys = Object.keys( cache );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tvar key = keys[ i ];\n\n\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > _removeThresholdCount ) {\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcache[ key ].used = false;\n\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction cleanupTable( table ) {\n\n\t\tvar keys = Object.keys( table );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tvar key = keys[ i ];\n\n\t\t\ttable[ key ] = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction cleanupCaches() {\n\n\t\tcleanupCache( _lightScenesCache );\n\t\tcleanupCache( _lightFullscreenScenesCache );\n\t\tcleanupCache( _normalDepthMaterialsCache );\n\t\tcleanupCache( _normalDepthShininessMaterialsCache );\n\t\tcleanupCache( _colorMaterialsCache );\n\t\tcleanupCache( _reconstructionMaterialsCache );\n\t\tcleanupCache( _classicDeferredLightMaterialsCache );\n\t\tcleanupCache( _lightPrePassMaterialsCache );\n\t\tcleanupCache( _deferredLightsCache );\n\n\t\tcleanupTable( _originalMaterialsTable );\n\t\tcleanupTable( _originalOnBeforeRendersTable );\n\t\tcleanupTable( _originalVisibleTable );\n\n\t}\n\n\t/*\n\t * Classic Deferred Rendering\n\t *\n\t * 1) g-buffer normal + depth pass\n\t *\n\t * RGB: normal\n\t *   A: depth\n\t *\n\t *\n\t * Light Pre-Pass Rendering\n\t *\n\t * 1') g-buffer normal + depth pass + shininess\n\t *\n\t *  RG: normal\n\t *   B: shininess\n\t *   A: depth\n\t */\n\n\tfunction renderNormalDepth( scene, camera ) {\n\n\t\tscene.traverse( setMaterialNormalDepth );\n\n\t\t_passNormalDepth.scene = scene;\n\t\t_passNormalDepth.camera = camera;\n\n\t\t_this.renderer.autoClearDepth = true;\n\t\t_this.renderer.autoClearStencil = true;\n\n\t\t_state.buffers.stencil.setTest( true );\n\t\t_state.buffers.stencil.setFunc( _context.ALWAYS, 1, 0xffffffff );\n\t\t_state.buffers.stencil.setOp( _context.REPLACE, _context.REPLACE, _context.REPLACE );\n\n\t\t_compNormalDepth.render();\n\n\t\tscene.traverse( restoreOriginalMaterial );\n\n\t}\n\n\t/*\n\t * Classic Deferred Rendering\n\t *\n\t * 2) g-buffer color pass\n\t *\n\t * R: diffuse\n\t * G: emissive\n\t * B: specular\n\t * A: shininess\n\t */\n\n\tfunction renderColor( scene, camera ) {\n\n\t\tscene.traverse( setMaterialColor );\n\n\t\t_passColor.scene = scene;\n\t\t_passColor.camera = camera;\n\n\t\t_this.renderer.autoClearDepth = false;\n\t\t_this.renderer.autoClearStencil = false;\n\n\t\t_state.buffers.stencil.setFunc( _context.EQUAL, 1, 0xffffffff );\n\t\t_state.buffers.stencil.setOp( _context.KEEP, _context.KEEP, _context.KEEP );\n\n\t\t_compColor.render();\n\n\t\tscene.traverse( restoreOriginalMaterial );\n\n\t}\n\n\t/*\n\t * Classic Deferred Rendering\n\t *\n\t * 3) light pass\n\t */\n\n\tfunction renderLight( scene, camera ) {\n\n\t\tscene.traverse( addDeferredLightsToLightScene );\n\n\t\tupdateDeferredLightsInLightScene( _lightScene );\n\t\tupdateDeferredLightsInLightScene( _lightFullscreenScene );\n\n\t\t_passLight.scene = _lightScene;\n\t\t_passLight.camera = camera;\n\n\t\t_passLightFullscreen.scene = _lightFullscreenScene;\n\n\t\t_this.renderer.autoClearDepth = false;\n\t\t_this.renderer.autoClearStencil = false;\n\n\t\t_compLight.render();\n\n\t\t_state.buffers.stencil.setTest( false );\n\n\t}\n\n\t/*\n\t * Light Pre-Pass Rendering\n\t *\n\t * 2') Light pre pass\n\t */\n\n\tfunction renderLightPre( scene, camera ) {\n\n\t\tscene.traverse( addDeferredLightsToLightScene );\n\n\t\tupdateDeferredLightsInLightScene( _lightScene );\n\t\tupdateDeferredLightsInLightScene( _lightFullscreenScene );\n\n\t\t_passLight.scene = _lightScene;\n\t\t_passLight.camera = camera;\n\n\t\t_passLightFullscreen.scene = _lightFullscreenScene;\n\n\t\t_this.renderer.autoClearDepth = false;\n\t\t_this.renderer.autoClearStencil = false;\n\n\t\t_state.buffers.stencil.setFunc( _context.EQUAL, 1, 0xffffffff );\n\t\t_state.buffers.stencil.setOp( _context.KEEP, _context.KEEP, _context.KEEP );\n\n\t\t_compLight.render();\n\n\t}\n\n\t/*\n\t * Light Pre-Pass Rendering\n\t *\n\t * 3') Reconstruction pass\n\t *\n\t * Transprency handling:\n\t * Here renders transparent objects with normal forward rendering.\n\t */\n\n\tfunction renderReconstruction( scene, camera ) {\n\n\t\tscene.traverse( setMaterialReconstruction );\n\n\t\t_passReconstruction.scene = scene;\n\t\t_passReconstruction.camera = camera;\n\n\t\t_this.renderer.autoClearDepth = false;\n\t\t_this.renderer.autoClearStencil = false;\n\n\t\t_compReconstruction.render();\n\n\t\t_state.buffers.stencil.setTest( false );\n\n\t\tscene.traverse( restoreOriginalMaterial );\n\n\t}\n\n\t/*\n\t * Classic Deferred Rendering\n\t *\n\t * 4) Final pass\n\t *\n\t * transparency handling:\n\t * If there's any transparent objects, here renders them on the deferred rendering result\n\t * with normal forward rendering. This may be the easist way but heavy.\n\t * We should consider any better ways someday.\n\t *\n\t *\n\t * Light Pre-Pass Rendering\n\t *\n\t * 4') Final pass\n\t *\n\t *\n\t * Common\n\t *\n\t * antialias handling:\n\t * Here uses postprocessing FXAA for antialias.\n\t *\n\t */\n\n\tfunction renderFinal( scene, camera ) {\n\n\t\tif ( ! _lightPrePass && _hasTransparentObject ) {\n\n\t\t\tscene.traverse( setVisibleForForwardRendering );\n\t\t\tscene.traverse( restoreOriginalOnBeforeRender );\n\n\t\t\t_passForward.scene = scene;\n\t\t\t_passForward.camera = camera;\n\n\t\t}\n\n\t\tenableFinalPasses();\n\n\t\t_this.renderer.autoClearDepth = false;\n\t\t_this.renderer.autoClearStencil = false;\n\n\t\t_compFinal.render();\n\n\t\tif ( ! _lightPrePass && _hasTransparentObject ) {\n\n\t\t\tscene.traverse( restoreVisible );\n\n\t\t}\n\n\t}\n\n\t// external APIs\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\tthis.renderer.setSize( _width, _height );\n\n\t\t_compNormalDepth.setSize( _width, _height );\n\t\t_compColor.setSize( _width, _height );\n\t\t_compLight.setSize( _width, _height );\n\t\t_compReconstruction.setSize( _width, _height );\n\t\t_compFinal.setSize( _width, _height );\n\n\t\t_depthTexture.image.width = _width;\n\t\t_depthTexture.image.height = _height;\n\t\t_depthTexture.needsUpdate = true;\n\n\t\t_passFXAA.uniforms.resolution.value.set( 1 / _width, 1 / _height );\n\n\t};\n\n\tthis.setAntialias = function ( enabled ) {\n\n\t\t_antialias = enabled;\n\n\t};\n\n\tthis.enableLightPrePass = function ( enabled ) {\n\n\t\t_lightPrePass = enabled;\n\n\t\t_passFinal.uniforms.samplerResult.value = ( _lightPrePass ) ? _compReconstruction.renderTarget2.texture : _compLight.renderTarget2.texture;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\t// for debug to compare with normal forward rendering\n\n\t\tif ( this.forwardRendering ) {\n\n\t\t\tthis.renderer.render( scene, camera );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\n\t\tvar currentAutoClearColor = this.renderer.autoClearColor;\n\t\tvar currentAutoClearDepth = this.renderer.autoClearDepth;\n\t\tvar currentAutoClearStencil = this.renderer.autoClearStencil;\n\n\t\t_currentCamera = camera;\n\n\t\tinitLightScene( scene );\n\n\t\tscene.autoUpdate = false;\n\t\tscene.updateMatrixWorld();\n\n\t\t_hasTransparentObject = false;\n\n\t\tscene.traverse( saveOriginalOnBeforeRenderAndCheckTransparency );\n\n\t\tupdateDeferredCommonUniforms( camera );\n\n\t\trenderNormalDepth( scene, camera );\n\n\t\tif ( _lightPrePass ) {\n\n\t\t\trenderLightPre( scene, camera );\n\t\t\trenderReconstruction( scene, camera );\n\n\t\t} else {\n\n\t\t\trenderColor( scene, camera );\n\t\t\trenderLight( scene, camera );\n\n\t\t}\n\n\t\trenderFinal( scene, camera );\n\n\t\tscene.traverse( restoreOriginalOnBeforeRender );\n\n\t\tcleanupCaches();\n\n\t\tscene.autoUpdate = currentSceneAutoUpdate;\n\t\tthis.renderer.autoClearColor = currentAutoClearColor;\n\t\tthis.renderer.autoClearDepth = currentAutoClearDepth;\n\t\tthis.renderer.autoClearStencil = currentAutoClearStencil;\n\n\t};\n\n\t// initialize\n\n\tinit( parameters );\n\n};\n\nTHREE.DeferredShaderChunk = {\n\n\tpackVector3: [\n\n\t\t\"float vec3_to_float( vec3 data ) {\",\n\n\t\t\"\tconst float unit = 255.0/256.0;\",\n\t\t\"\thighp float compressed = fract( data.x * unit ) + floor( data.y * unit * 255.0 ) + floor( data.z * unit * 255.0 ) * 255.0;\",\n\t\t\"\treturn compressed;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tunpackFloat: [\n\n\t\t\"vec3 float_to_vec3( float data ) {\",\n\n\t\t\"\tconst float unit = 255.0;\",\n\t\t\"\tvec3 uncompressed;\",\n\t\t\"\tuncompressed.x = fract( data );\",\n\t\t\"\tfloat zInt = floor( data / unit );\",\n\t\t\"\tuncompressed.z = fract( zInt / unit );\",\n\t\t\"\tuncompressed.y = fract( floor( data - ( zInt * unit ) ) / unit );\",\n\t\t\"\treturn uncompressed;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\t// Refer to http://aras-p.info/texts/CompactNormalStorage.html\n\tpackNormal: [\n\n\t\t\"vec2 normal_to_vec2( vec3 normal ) {\",\n\n\t\t\"\treturn normal.xy / sqrt( normal.z * 8.0 + 8.0 ) + 0.5;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tunpackVector2: [\n\n\t\t\"vec3 vec2_to_normal( vec2 data ) {\",\n\n\t\t\"\tvec2 fenc = data * 4.0 - 2.0;\",\n\t\t\"\tfloat f = dot( fenc, fenc );\",\n\t\t\"\tfloat g = sqrt( 1.0 - f / 4.0 );\",\n\t\t\"\tvec3 normal;\",\n\t\t\"\tnormal.xy = fenc * g;\",\n\t\t\"\tnormal.z = 1.0 - f / 2.0;\",\n\t\t\"\treturn normal;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tcomputeTextureCoord: [\n\n\t\t\"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\"\n\n\t].join( \"\\n\" ),\n\n\tpackNormalDepth: [\n\n\t\t\"vec4 packedNormalDepth;\",\n\t\t\"packedNormalDepth.xyz = normal * 0.5 + 0.5;\",\n\t\t\"packedNormalDepth.w = position.z / position.w;\"\n\n\t].join( \"\\n\" ),\n\n\tunpackNormalDepth: [\n\n\t\t\"vec4 normalDepthMap = texture2D( samplerNormalDepth, texCoord );\",\n\t\t\"float depth = normalDepthMap.w;\",\n\n\t\t\"if ( depth == 0.0 ) discard;\",\n\n\t\t\"vec3 normal = normalDepthMap.xyz * 2.0 - 1.0;\"\n\n\t].join( \"\\n\" ),\n\n\tpackNormalDepthShininess: [\n\n\t\t\"vec4 packedNormalDepthShininess;\",\n\t\t\"packedNormalDepthShininess.xy = normal_to_vec2( normal );\",\n\t\t\"packedNormalDepthShininess.z = shininess;\",\n\t\t\"packedNormalDepthShininess.w = position.z / position.w;\"\n\n\t].join( \"\\n\" ),\n\n\tunpackNormalDepthShininess: [\n\n\t\t\"vec4 normalDepthMap = texture2D( samplerNormalDepthShininess, texCoord );\",\n\t\t\"float depth = normalDepthMap.w;\",\n\n\t\t\"if ( depth == 0.0 ) discard;\",\n\n\t\t\"vec3 normal = vec2_to_normal( normalDepthMap.xy );\",\n\t\t\"float shininess = normalDepthMap.z;\"\n\n\t].join( \"\\n\" ),\n\n\tpackColor: [\n\n\t\t\"vec4 packedColor;\",\n\t\t\"packedColor.x = vec3_to_float( diffuseColor.rgb );\",\n\t\t\"packedColor.y = vec3_to_float( emissiveColor );\",\n\t\t\"packedColor.z = vec3_to_float( specularColor );\",\n\t\t\"packedColor.w = shininess;\"\n\n\t].join( \"\\n\" ),\n\n\tunpackColor: [\n\n\t\t\"vec4 colorMap = texture2D( samplerColor, texCoord );\",\n\t\t\"vec3 diffuseColor = float_to_vec3( colorMap.x );\",\n\t\t\"vec3 emissiveColor = float_to_vec3( colorMap.y );\",\n\t\t\"vec3 specularColor = float_to_vec3( colorMap.z );\",\n\t\t\"float shininess = colorMap.w;\"\n\n\t].join( \"\\n\" ),\n\n\tpackLight: [\n\n\t\t\"vec4 packedLight;\",\n\t\t\"packedLight.xyz = lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * attenuation;\",\n\t\t\"packedLight.w = lightIntensity * specular * max( dot( lightVector, normal ), 0.0 ) * attenuation;\"\n\n\t].join( \"\\n\" ),\n\n\tcomputeVertexPositionVS: [\n\n\t\t\"vec2 xy = texCoord * 2.0 - 1.0;\",\n\t\t\"vec4 vertexPositionProjected = vec4( xy, depth, 1.0 );\",\n\t\t\"vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;\",\n\t\t\"vertexPositionVS.xyz /= vertexPositionVS.w;\",\n\t\t\"vertexPositionVS.w = 1.0;\"\n\n\t].join( \"\\n\" ),\n\n\t// TODO: calculate schlick\n\tcomputeSpecular: [\n\n\t\t\"vec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );\",\n\t\t\"float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );\",\n\t\t\"float specular = 0.31830988618 * ( shininess * 0.5 + 1.0 ) * pow( dotNormalHalf, shininess );\"\n\n\t].join( \"\\n\" ),\n\n\tcombine: [\n\n\t\t\"gl_FragColor = vec4( lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * ( diffuseColor + specular * specularColor ) * attenuation, 1.0 );\"\n\n\t].join( \"\\n\" )\n\n};\n\nTHREE.ShaderDeferredCommon = {\n\n\tcommonUniforms: {\n\n\t\tmatProjInverse: new THREE.Uniform( new THREE.Matrix4() ),\n\n\t\tviewWidth: new THREE.Uniform( 800 ),\n\t\tviewHeight: new THREE.Uniform( 600 )\n\n\t}\n\n};\n\nTHREE.ShaderDeferred = {\n\n\tnormalDepth: {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec4 vPosition;\",\n\n\t\t\t\"#include <morphtarget_pars_vertex>\",\n\t\t\t\"#include <skinning_pars_vertex>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"#include <begin_vertex>\",\n\t\t\t\"#include <beginnormal_vertex>\",\n\t\t\t\"#include <skinbase_vertex>\",\n\t\t\t\"#include <skinnormal_vertex>\",\n\t\t\t\"#include <defaultnormal_vertex>\",\n\t\t\t\"#include <morphtarget_vertex>\",\n\t\t\t\"#include <skinning_vertex>\",\n\t\t\t\"#include <project_vertex>\",\n\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\n\t\t\t\"\tvPosition = gl_Position;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec4 vPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 normal = vNormal;\",\n\t\t\t\"\tvec4 position = vPosition;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packNormalDepth\" ],\n\n\t\t\t\"\tgl_FragColor = packedNormalDepth;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tcolor: {\n\n\t\tuniforms: {\n\n\t\t\tmap: new THREE.Uniform( null ),\n\t\t\toffsetRepeat: new THREE.Uniform( new THREE.Vector4( 0, 0, 1, 1 ) ),\n\n\t\t\tdiffuse: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\temissive: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\tspecular: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\tshininess: new THREE.Uniform( 30.0 )\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"#include <uv_pars_vertex>\",\n\t\t\t\"#include <morphtarget_pars_vertex>\",\n\t\t\t\"#include <skinning_pars_vertex>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"#include <uv_vertex>\",\n\t\t\t\"#include <begin_vertex>\",\n\t\t\t\"#include <beginnormal_vertex>\",\n\t\t\t\"#include <skinbase_vertex>\",\n\t\t\t\"#include <skinnormal_vertex>\",\n\t\t\t\"#include <defaultnormal_vertex>\",\n\t\t\t\"#include <morphtarget_vertex>\",\n\t\t\t\"#include <skinning_vertex>\",\n\t\t\t\"#include <project_vertex>\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\t\"#include <uv_pars_fragment>\",\n\t\t\t\"#include <map_pars_fragment>\",\n\t\t\tTHREE.DeferredShaderChunk[ \"packVector3\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, 1.0 );\",\n\t\t\t\"\tvec3 emissiveColor = emissive;\",\n\t\t\t\"\tvec3 specularColor = specular;\",\n\n\t\t\t\"#include <map_fragment>\",\n\t\t\tTHREE.DeferredShaderChunk[ \"packColor\" ],\n\n\t\t\t\"\tgl_FragColor = packedColor;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\temissiveLight: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerColor: new THREE.Uniform( null )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() { \",\n\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerColor;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackColor\" ],\n\n\t\t\t\"\tgl_FragColor = vec4( emissiveColor, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' )\n\n\t},\n\n\tpointLight: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepth: new THREE.Uniform( null ),\n\t\t\t\tsamplerColor: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightPositionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 ),\n\t\t\t\tlightRadius: new THREE.Uniform( 1.0 )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\n\t\t\t\"uniform sampler2D samplerColor;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightPositionVS;\",\n\t\t\t\"uniform float lightIntensity;\",\n\t\t\t\"uniform float lightRadius;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepth\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\n\t\t\t\"\tvec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\",\n\t\t\t\"\tfloat distance = length( lightVector );\",\n\n\t\t\t\"\tif ( distance > lightRadius ) discard;\",\n\n\t\t\t\"\tlightVector = normalize( lightVector );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackColor\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\t//float cutoff = 0.3;\",\n\t\t\t\"\t//float denom = distance / lightRadius + 1.0;\",\n\t\t\t\"\t//float attenuation = 1.0 / ( denom * denom );\",\n\t\t\t\"\t//attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );\",\n\t\t\t\"\t//attenuation = max( attenuation, 0.0 );\",\n\t\t\t\"\t//attenuation *= attenuation;\",\n\n\t\t\t\"\t//diffuseColor *= saturate( -distance / lightRadius + 1.0 );\",\n\t\t\t\"\t//float attenuation = 1.0;\",\n\n\t\t\t\"\tfloat attenuation = saturate( -distance / lightRadius + 1.0 );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"combine\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tspotLight: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepth: new THREE.Uniform( null ),\n\t\t\t\tsamplerColor: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightDirectionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightPositionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightAngle: new THREE.Uniform( 1.0 ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() { \",\n\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\n\t\t\t\"uniform sampler2D samplerColor;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightPositionVS;\",\n\t\t\t\"uniform vec3 lightDirectionVS;\",\n\t\t\t\"uniform float lightAngle;\",\n\t\t\t\"uniform float lightIntensity;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepth\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackColor\" ],\n\n\t\t\t\"\tvec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\",\n\n\t\t\t\"\tfloat rho = dot( lightDirectionVS, lightVector );\",\n\t\t\t\"\tfloat rhoMax = cos( lightAngle );\",\n\n\t\t\t\"\tif ( rho <= rhoMax ) discard;\",\n\n\t\t\t\"\tfloat theta = rhoMax + 0.0001;\",\n\t\t\t\"\tfloat phi = rhoMax + 0.05;\",\n\t\t\t\"\tfloat falloff = 4.0;\",\n\n\t\t\t\"\tfloat spot = 0.0;\",\n\n\t\t\t\"\tif ( rho >= phi ) {\",\n\n\t\t\t\"\t\tspot = 1.0;\",\n\n\t\t\t\"\t} else if ( rho <= theta ) {\",\n\n\t\t\t\"\t\tspot = 0.0;\",\n\n\t\t\t\"\t} else { \",\n\n\t\t\t\"\t\tspot = pow( ( rho - theta ) / ( phi - theta ), falloff );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tdiffuseColor *= spot;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\tconst float attenuation = 1.0;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"combine\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tdirectionalLight: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepth: new THREE.Uniform( null ),\n\t\t\t\tsamplerColor: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightDirectionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 )\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() { \",\n\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\n\t\t\t\"uniform sampler2D samplerColor;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightDirectionVS;\",\n\t\t\t\"uniform float lightIntensity;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepth\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackColor\" ],\n\n\t\t\t\"\tvec3 lightVector = normalize( lightDirectionVS );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\tconst float attenuation = 1.0;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"combine\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' )\n\n\t},\n\n\tnormalDepthShininess: {\n\n\t\tuniforms: {\n\n\t\t\tshininess: new THREE.Uniform( 30.0 )\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec4 vPosition;\",\n\n\t\t\t\"#include <morphtarget_pars_vertex>\",\n\t\t\t\"#include <skinning_pars_vertex>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"#include <begin_vertex>\",\n\t\t\t\"#include <beginnormal_vertex>\",\n\t\t\t\"#include <skinbase_vertex>\",\n\t\t\t\"#include <skinnormal_vertex>\",\n\t\t\t\"#include <defaultnormal_vertex>\",\n\t\t\t\"#include <morphtarget_vertex>\",\n\t\t\t\"#include <skinning_vertex>\",\n\t\t\t\"#include <project_vertex>\",\n\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\n\t\t\t\"\tvPosition = gl_Position;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec4 vPosition;\",\n\n\t\t\t\"uniform float shininess;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packNormal\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 normal = vNormal;\",\n\t\t\t\"\tvec4 position = vPosition;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packNormalDepthShininess\" ],\n\n\t\t\t\"\tgl_FragColor = packedNormalDepthShininess;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tpointLightPre: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepthShininess: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightPositionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 ),\n\t\t\t\tlightRadius: new THREE.Uniform( 1.0 )\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightPositionVS;\",\n\t\t\t\"uniform float lightIntensity;\",\n\t\t\t\"uniform float lightRadius;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackVector2\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\n\t\t\t\"\tvec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\",\n\t\t\t\"\tfloat distance = length( lightVector );\",\n\n\t\t\t\"\tif ( distance > lightRadius ) discard;\",\n\n\t\t\t\"\tlightVector = normalize( lightVector );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\tfloat attenuation = saturate( -distance / lightRadius + 1.0 );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packLight\" ],\n\n\t\t\t\"\tgl_FragColor = packedLight;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tspotLightPre: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepthShininess: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightDirectionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightPositionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightAngle: new THREE.Uniform( 1.0 ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() { \",\n\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightPositionVS;\",\n\t\t\t\"uniform vec3 lightDirectionVS;\",\n\t\t\t\"uniform float lightAngle;\",\n\t\t\t\"uniform float lightIntensity;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackVector2\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\n\t\t\t\"\tvec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\",\n\n\t\t\t\"\tfloat rho = dot( lightDirectionVS, lightVector );\",\n\t\t\t\"\tfloat rhoMax = cos( lightAngle );\",\n\n\t\t\t\"\tif ( rho <= rhoMax ) discard;\",\n\n\t\t\t\"\tfloat theta = rhoMax + 0.0001;\",\n\t\t\t\"\tfloat phi = rhoMax + 0.05;\",\n\t\t\t\"\tfloat falloff = 4.0;\",\n\n\t\t\t\"\tfloat spot = 0.0;\",\n\n\t\t\t\"\tif ( rho >= phi ) {\",\n\n\t\t\t\"\t\tspot = 1.0;\",\n\n\t\t\t\"\t} else if ( rho <= theta ) {\",\n\n\t\t\t\"\t\tspot = 0.0;\",\n\n\t\t\t\"\t} else { \",\n\n\t\t\t\"\t\tspot = pow( ( rho - theta ) / ( phi - theta ), falloff );\",\n\n\t\t\t\"\t}\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\tconst float attenuation = 1.0;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packLight\" ],\n\n\t\t\t\"\tgl_FragColor = spot * packedLight;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\tdirectionalLightPre: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerNormalDepthShininess: new THREE.Uniform( null ),\n\n\t\t\t\tlightColor: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tlightDirectionVS: new THREE.Uniform( new THREE.Vector3( 0, 1, 0 ) ),\n\t\t\t\tlightIntensity: new THREE.Uniform( 1.0 )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() { \",\n\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"uniform vec3 lightColor;\",\n\t\t\t\"uniform vec3 lightDirectionVS;\",\n\t\t\t\"uniform float lightIntensity;\",\n\n\t\t\t\"uniform mat4 matProjInverse;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackVector2\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\n\t\t\tTHREE.DeferredShaderChunk[ \"computeVertexPositionVS\" ],\n\n\t\t\t\"\tvec3 lightVector = normalize( lightDirectionVS );\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeSpecular\" ],\n\n\t\t\t\"\tconst float attenuation = 1.0;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"packLight\" ],\n\n\t\t\t\"\tgl_FragColor = packedLight;\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' )\n\n\t},\n\n\treconstruction: {\n\n\t\tuniforms: Object.assign(\n\n\t\t\t{\n\n\t\t\t\tsamplerLight: new THREE.Uniform( null ),\n\n\t\t\t\tmap: new THREE.Uniform( null ),\n\t\t\t\toffsetRepeat: new THREE.Uniform( new THREE.Vector4( 0, 0, 1, 1 ) ),\n\n\t\t\t\tdiffuse: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\temissive: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tspecular: new THREE.Uniform( new THREE.Color( 0x000000 ) ),\n\t\t\t\tshininess: new THREE.Uniform( 30.0 )\n\n\t\t\t},\n\n\t\t\tTHREE.ShaderDeferredCommon[ 'commonUniforms' ]\n\n\t\t),\n\n\t\tvertexShader: [\n\n\t\t\t\"#include <uv_pars_vertex>\",\n\t\t\t\"#include <morphtarget_pars_vertex>\",\n\t\t\t\"#include <skinning_pars_vertex>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"#include <uv_vertex>\",\n\t\t\t\"#include <begin_vertex>\",\n\t\t\t\"#include <beginnormal_vertex>\",\n\t\t\t\"#include <skinbase_vertex>\",\n\t\t\t\"#include <skinnormal_vertex>\",\n\t\t\t\"#include <defaultnormal_vertex>\",\n\t\t\t\"#include <morphtarget_vertex>\",\n\t\t\t\"#include <skinning_vertex>\",\n\t\t\t\"#include <project_vertex>\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D samplerLight;\",\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\t\"uniform float viewHeight;\",\n\t\t\t\"uniform float viewWidth;\",\n\n\t\t\t\"#include <uv_pars_fragment>\",\n\t\t\t\"#include <map_pars_fragment>\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"unpackFloat\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, 1.0 );\",\n\t\t\t\"\tvec3 emissiveColor = emissive;\",\n\t\t\t\"\tvec3 specularColor = specular;\",\n\n\t\t\tTHREE.DeferredShaderChunk[ \"computeTextureCoord\" ],\n\n\t\t\t\"\tvec4 light = texture2D( samplerLight, texCoord );\",\n\n\t\t\t\"#include <map_fragment>\",\n\n\t\t\t\"\tvec3 diffuseFinal = diffuseColor.rgb * light.rgb;\",\n\t\t\t\"\tvec3 emissiveFinal = emissiveColor;\",\n\t\t\t\"\tvec3 specularFinal = specularColor * light.rgb * light.a;\",\n\n\t\t\t\"\tgl_FragColor = vec4( diffuseFinal + emissiveFinal + specularFinal, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\t// TODO: implement tone mapping\n\tfinal: {\n\n\t\tuniforms: {\n\n\t\t\tsamplerResult: new THREE.Uniform( null )\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 texCoord;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );\",\n\t\t\t\"\ttexCoord = pos.xy * vec2( 0.5 ) + 0.5;\",\n\t\t\t\"\tgl_Position = pos;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 texCoord;\",\n\t\t\t\"uniform sampler2D samplerResult;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_FragColor = texture2D( samplerResult, texCoord );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n\n"],"mappings":"AACA","sourceRoot":""}