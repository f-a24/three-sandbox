{"version":3,"file":"21.3c5fc071e544c77027a1.bundle.js","sources":["webpack:///./src/utils/d3-threeD.ts"],"sourcesContent":["import * as THREE from 'three';\r\n\r\nconst DEGS_TO_RADS = Math.PI / 180;\r\n\r\nconst DIGIT_0 = 48,\r\n  DIGIT_9 = 57,\r\n  COMMA = 44,\r\n  SPACE = 32,\r\n  PERIOD = 46,\r\n  MINUS = 45;\r\n\r\nconst transformSVGPathExposed = (pathStr: string): THREE.Shape[] => {\r\n  const paths = [] as THREE.Shape[];\r\n  let path = new THREE.Shape();\r\n\r\n  let idx = 1,\r\n    len = pathStr.length,\r\n    activeCmd,\r\n    x = 0,\r\n    y = 0,\r\n    nx = 0,\r\n    ny = 0,\r\n    firstX = null,\r\n    firstY = null,\r\n    x1 = 0,\r\n    x2 = 0,\r\n    y1 = 0,\r\n    y2 = 0,\r\n    rx = 0,\r\n    ry = 0,\r\n    xar = 0,\r\n    laf = 0,\r\n    sf = 0,\r\n    cx,\r\n    cy;\r\n\r\n  function eatNum() {\r\n    let sidx,\r\n      c,\r\n      isFloat = false,\r\n      s;\r\n    // eat delims\r\n    while (idx < len) {\r\n      c = pathStr.charCodeAt(idx);\r\n      if (c !== COMMA && c !== SPACE) break;\r\n      idx++;\r\n    }\r\n    if (c === MINUS) sidx = idx++;\r\n    else sidx = idx;\r\n    // eat number\r\n    while (idx < len) {\r\n      c = pathStr.charCodeAt(idx);\r\n      if (DIGIT_0 <= c && c <= DIGIT_9) {\r\n        idx++;\r\n        continue;\r\n      } else if (c === PERIOD) {\r\n        idx++;\r\n        isFloat = true;\r\n        continue;\r\n      }\r\n\r\n      s = pathStr.substring(sidx, idx);\r\n      return isFloat ? parseFloat(s) : parseInt(s);\r\n    }\r\n\r\n    s = pathStr.substring(sidx);\r\n    return isFloat ? parseFloat(s) : parseInt(s);\r\n  }\r\n\r\n  function nextIsNum() {\r\n    let c;\r\n    // do permanently eat any delims...\r\n    while (idx < len) {\r\n      c = pathStr.charCodeAt(idx);\r\n      if (c !== COMMA && c !== SPACE) break;\r\n      idx++;\r\n    }\r\n    c = pathStr.charCodeAt(idx);\r\n    return c === MINUS || (DIGIT_0 <= c && c <= DIGIT_9);\r\n  }\r\n\r\n  let canRepeat;\r\n  let enteredSub = false;\r\n  let zSeen = false;\r\n  activeCmd = pathStr[0];\r\n\r\n  while (idx <= len) {\r\n    canRepeat = true;\r\n    switch (activeCmd) {\r\n      // moveto commands, become lineto's if repeated\r\n      case 'M':\r\n        enteredSub = false;\r\n        x = eatNum();\r\n        y = eatNum();\r\n        path.moveTo(x, y);\r\n        activeCmd = 'L';\r\n        break;\r\n      case 'm':\r\n        x += eatNum();\r\n        y += eatNum();\r\n        path.moveTo(x, y);\r\n        activeCmd = 'l';\r\n        break;\r\n      case 'Z':\r\n      case 'z':\r\n        canRepeat = false;\r\n        if (x !== firstX || y !== firstY) path.lineTo(firstX, firstY);\r\n\r\n        paths.push(path);\r\n\r\n        // reset the elements\r\n        firstX = null;\r\n        firstY = null;\r\n\r\n        // avoid x,y being set incorrectly\r\n        enteredSub = true;\r\n\r\n        path = new THREE.Shape();\r\n\r\n        zSeen = true;\r\n\r\n        break;\r\n      // - lines!\r\n      case 'L':\r\n      case 'H':\r\n      case 'V':\r\n        nx = activeCmd === 'V' ? x : eatNum();\r\n        ny = activeCmd === 'H' ? y : eatNum();\r\n        path.lineTo(nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      case 'l':\r\n      case 'h':\r\n      case 'v':\r\n        nx = activeCmd === 'v' ? x : x + eatNum();\r\n        ny = activeCmd === 'h' ? y : y + eatNum();\r\n        path.lineTo(nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      // - cubic bezier\r\n      case 'C':\r\n        x1 = eatNum();\r\n        y1 = eatNum();\r\n      case 'S':\r\n        if (activeCmd === 'S') {\r\n          x1 = 2 * x - x2;\r\n          y1 = 2 * y - y2;\r\n        }\r\n        x2 = eatNum();\r\n        y2 = eatNum();\r\n        nx = eatNum();\r\n        ny = eatNum();\r\n        path.bezierCurveTo(x1, y1, x2, y2, nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      case 'c':\r\n        x1 = x + eatNum();\r\n        y1 = y + eatNum();\r\n      case 's':\r\n        if (activeCmd === 's') {\r\n          x1 = 2 * x - x2;\r\n          y1 = 2 * y - y2;\r\n        }\r\n        x2 = x + eatNum();\r\n        y2 = y + eatNum();\r\n        nx = x + eatNum();\r\n        ny = y + eatNum();\r\n        path.bezierCurveTo(x1, y1, x2, y2, nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      // - quadratic bezier\r\n      case 'Q':\r\n        x1 = eatNum();\r\n        y1 = eatNum();\r\n      case 'T':\r\n        if (activeCmd === 'T') {\r\n          x1 = 2 * x - x1;\r\n          y1 = 2 * y - y1;\r\n        }\r\n        nx = eatNum();\r\n        ny = eatNum();\r\n        path.quadraticCurveTo(x1, y1, nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      case 'q':\r\n        x1 = x + eatNum();\r\n        y1 = y + eatNum();\r\n      case 't':\r\n        if (activeCmd === 't') {\r\n          x1 = 2 * x - x1;\r\n          y1 = 2 * y - y1;\r\n        }\r\n        nx = x + eatNum();\r\n        ny = y + eatNum();\r\n        path.quadraticCurveTo(x1, y1, nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n      // - elliptical arc\r\n      case 'A':\r\n        rx = eatNum();\r\n        ry = eatNum();\r\n        xar = eatNum() * DEGS_TO_RADS;\r\n        laf = eatNum();\r\n        sf = eatNum();\r\n        nx = eatNum();\r\n        ny = eatNum();\r\n        if (rx !== ry) {\r\n          console.warn(\r\n            'Forcing elliptical arc to be a circular one :(',\r\n            rx,\r\n            ry\r\n          );\r\n        }\r\n        // SVG implementation notes does all the math for us! woo!\r\n        // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n        // step1, using x1 as x1'\r\n        x1 = (Math.cos(xar) * (x - nx)) / 2 + (Math.sin(xar) * (y - ny)) / 2;\r\n        y1 = (-Math.sin(xar) * (x - nx)) / 2 + (Math.cos(xar) * (y - ny)) / 2;\r\n        // step 2, using x2 as cx'\r\n        let norm = Math.sqrt(\r\n          (rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) /\r\n            (rx * rx * y1 * y1 + ry * ry * x1 * x1)\r\n        );\r\n        if (laf === sf) norm = -norm;\r\n        x2 = (norm * rx * y1) / ry;\r\n        y2 = (norm * -ry * x1) / rx;\r\n        // step 3\r\n        cx = Math.cos(xar) * x2 - Math.sin(xar) * y2 + (x + nx) / 2;\r\n        cy = Math.sin(xar) * x2 + Math.cos(xar) * y2 + (y + ny) / 2;\r\n\r\n        let u = new THREE.Vector2(1, 0),\r\n          v = new THREE.Vector2((x1 - x2) / rx, (y1 - y2) / ry);\r\n        let startAng = Math.acos(u.dot(v) / u.length() / v.length());\r\n        if (u.x * v.y - u.y * v.x < 0) startAng = -startAng;\r\n\r\n        // we can reuse 'v' from start angle as our 'u' for delta angle\r\n        u.x = (-x1 - x2) / rx;\r\n        u.y = (-y1 - y2) / ry;\r\n\r\n        let deltaAng = Math.acos(v.dot(u) / v.length() / u.length());\r\n        // This normalization ends up making our curves fail to triangulate...\r\n        if (v.x * u.y - v.y * u.x < 0) deltaAng = -deltaAng;\r\n        if (!sf && deltaAng > 0) deltaAng -= Math.PI * 2;\r\n        if (sf && deltaAng < 0) deltaAng += Math.PI * 2;\r\n\r\n        path.absarc(cx, cy, rx, startAng, startAng + deltaAng, Boolean(sf));\r\n        x = nx;\r\n        y = ny;\r\n        break;\r\n\r\n      case ' ':\r\n        // if it's an empty space, just skip it, and see if we can find a real command\r\n        break;\r\n\r\n      default:\r\n        throw new Error('weird path command: ' + activeCmd);\r\n    }\r\n    if (firstX === null && !enteredSub) {\r\n      firstX = x;\r\n      firstY = y;\r\n    }\r\n\r\n    // just reissue the command\r\n    if (canRepeat && nextIsNum()) continue;\r\n    activeCmd = pathStr[idx++];\r\n  }\r\n\r\n  if (zSeen) {\r\n    return paths;\r\n  } else {\r\n    paths.push(path);\r\n    return paths;\r\n  }\r\n};\r\n\r\nexport { transformSVGPathExposed };\r\n"],"mappings":"AAEA","sourceRoot":""}