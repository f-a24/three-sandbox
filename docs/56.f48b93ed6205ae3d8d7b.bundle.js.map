{"version":3,"file":"56.f48b93ed6205ae3d8d7b.bundle.js","sources":["webpack:///./src/chapter7/7.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport * as Stats from 'stats.js';\r\nimport * as dat from 'dat.gui';\r\n\r\nexport default () => {\r\n  // 画面サイズ\r\n  const VIEWPORT_W = window.innerWidth;\r\n  const VIEWPORT_H = window.innerHeight;\r\n\r\n  /* scene */\r\n  const scene = new THREE.Scene();\r\n\r\n  /* camera */\r\n  const camera = new THREE.PerspectiveCamera(\r\n    45,\r\n    VIEWPORT_W / VIEWPORT_H,\r\n    0.1,\r\n    200\r\n  );\r\n  camera.position.x = 20;\r\n  camera.position.y = 40;\r\n  camera.position.z = 110;\r\n  camera.lookAt(new THREE.Vector3(20, 30, 0));\r\n\r\n  /* renderer */\r\n  const renderer = new THREE.WebGLRenderer();\r\n  renderer.setClearColor(new THREE.Color(0x000000));\r\n  renderer.setSize(VIEWPORT_W, VIEWPORT_H);\r\n\r\n  const velocities: { x: number; y: number; z: number }[] = [];\r\n  const createPoints = (\r\n    name: string,\r\n    texture: THREE.Texture,\r\n    size: number,\r\n    transparent: boolean,\r\n    opacity: number,\r\n    sizeAttenuation: boolean,\r\n    color: number\r\n  ) => {\r\n    const geom = new THREE.Geometry();\r\n    const newColor = new THREE.Color(color);\r\n    newColor.setHSL(\r\n      newColor.getHSL({} as THREE.HSL).h,\r\n      newColor.getHSL({} as THREE.HSL).s,\r\n      Math.random() * newColor.getHSL({} as THREE.HSL).l\r\n    );\r\n    const material = new THREE.PointsMaterial({\r\n      size: size,\r\n      transparent: transparent,\r\n      opacity: opacity,\r\n      map: texture,\r\n      blending: THREE.AdditiveBlending,\r\n      depthWrite: false,\r\n      sizeAttenuation: sizeAttenuation,\r\n      color: color\r\n    });\r\n\r\n    const range = 40;\r\n    for (let i = 0; i < 50; i++) {\r\n      const particle = new THREE.Vector3(\r\n        Math.random() * range - range / 2,\r\n        Math.random() * range * 1.5,\r\n        Math.random() * range - range / 2\r\n      );\r\n      velocities.push({\r\n        x: (Math.random() - 0.5) / 3,\r\n        y: 0.1 + Math.random() / 5,\r\n        z: (Math.random() - 0.5) / 3\r\n      });\r\n      geom.vertices.push(particle);\r\n    }\r\n    const system = new THREE.Points(geom, material);\r\n    system.name = name;\r\n    return system;\r\n  };\r\n\r\n  const createMultiPoints = (\r\n    size: number,\r\n    transparent: boolean,\r\n    opacity: number,\r\n    sizeAttenuation: boolean,\r\n    color: number\r\n  ) => {\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const texture1 = textureLoader.load('./assets/snowflake1.png');\r\n    const texture2 = textureLoader.load('./assets/snowflake2.png');\r\n    const texture3 = textureLoader.load('./assets/snowflake3.png');\r\n    const texture4 = textureLoader.load('./assets/snowflake5.png');\r\n    scene.add(\r\n      createPoints(\r\n        'system1',\r\n        texture1,\r\n        size,\r\n        transparent,\r\n        opacity,\r\n        sizeAttenuation,\r\n        color\r\n      )\r\n    );\r\n    scene.add(\r\n      createPoints(\r\n        'system2',\r\n        texture2,\r\n        size,\r\n        transparent,\r\n        opacity,\r\n        sizeAttenuation,\r\n        color\r\n      )\r\n    );\r\n    scene.add(\r\n      createPoints(\r\n        'system3',\r\n        texture3,\r\n        size,\r\n        transparent,\r\n        opacity,\r\n        sizeAttenuation,\r\n        color\r\n      )\r\n    );\r\n    scene.add(\r\n      createPoints(\r\n        'system4',\r\n        texture4,\r\n        size,\r\n        transparent,\r\n        opacity,\r\n        sizeAttenuation,\r\n        color\r\n      )\r\n    );\r\n  };\r\n\r\n  document.getElementById('WebGL-output').appendChild(renderer.domElement);\r\n\r\n  const controls = {\r\n    size: 10,\r\n    transparent: true,\r\n    opacity: 0.6,\r\n    color: 0xffffff,\r\n    sizeAttenuation: true,\r\n    redraw: () => {\r\n      const toRemove = [];\r\n      scene.children.forEach(child => {\r\n        if (child instanceof THREE.Points) {\r\n          toRemove.push(child);\r\n        }\r\n      });\r\n      toRemove.forEach(function(child) {\r\n        scene.remove(child);\r\n      });\r\n      createMultiPoints(\r\n        controls.size,\r\n        controls.transparent,\r\n        controls.opacity,\r\n        controls.sizeAttenuation,\r\n        controls.color\r\n      );\r\n    }\r\n  };\r\n\r\n  /* gui */\r\n  const gui = new dat.GUI();\r\n  gui.add(controls, 'size', 0, 20).onChange(controls.redraw);\r\n  gui.add(controls, 'transparent').onChange(controls.redraw);\r\n  gui.add(controls, 'opacity', 0, 1).onChange(controls.redraw);\r\n  gui.addColor(controls, 'color').onChange(controls.redraw);\r\n  gui.add(controls, 'sizeAttenuation').onChange(controls.redraw);\r\n\r\n  /* stats */\r\n  const initStats = () => {\r\n    const statsObj = new Stats();\r\n    statsObj.showPanel(0);\r\n    statsObj.dom.style.position = 'absolute';\r\n    statsObj.dom.style.left = '0px';\r\n    statsObj.dom.style.top = '0px';\r\n    document.getElementById('Stats-output').appendChild(statsObj.dom);\r\n    return statsObj;\r\n  };\r\n  const stats = initStats();\r\n\r\n  /* render */\r\n  const renderScene = () => {\r\n    stats.update();\r\n\r\n    scene.children.forEach(child => {\r\n      if (child instanceof THREE.Points) {\r\n        const vertices = (child.geometry as THREE.Geometry).vertices;\r\n        vertices.forEach((v, i) => {\r\n          v.x = v.x - velocities[i].x;\r\n          v.y = v.y - velocities[i].y;\r\n          v.z = v.z - velocities[i].z;\r\n          if (v.x <= -20 || v.x >= 20) velocities[i].x = velocities[i].x * -1;\r\n          if (v.y <= 0) v.y = 60;\r\n          if (v.z <= -20 || v.z >= 20) velocities[i].z = velocities[i].z * -1;\r\n        });\r\n        (child.geometry as THREE.Geometry).verticesNeedUpdate = true;\r\n      }\r\n    });\r\n\r\n    requestAnimationFrame(renderScene);\r\n    renderer.render(scene, camera);\r\n  };\r\n  controls.redraw();\r\n  renderScene();\r\n};\r\n"],"mappings":"AAAA","sourceRoot":""}