{"version":3,"file":"42.3c5fc071e544c77027a1.bundle.js","sources":["webpack:///./src/chapter8/1.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport * as Stats from 'stats.js';\r\nimport * as dat from 'dat.gui';\r\nimport createMultiMaterialObject from '../utils/createMultiMaterialObject';\r\n\r\nexport default () => {\r\n  // 画面サイズ\r\n  const VIEWPORT_W = window.innerWidth;\r\n  const VIEWPORT_H = window.innerHeight;\r\n\r\n  /* scene */\r\n  const scene = new THREE.Scene();\r\n\r\n  /* camera */\r\n  const camera = new THREE.PerspectiveCamera(\r\n    45,\r\n    VIEWPORT_W / VIEWPORT_H,\r\n    0.1,\r\n    1000\r\n  );\r\n  camera.position.x = 30;\r\n  camera.position.y = 30;\r\n  camera.position.z = 30;\r\n  camera.lookAt(new THREE.Vector3(0, 0, 0));\r\n\r\n  /* renderer */\r\n  const renderer = new THREE.WebGLRenderer();\r\n  renderer.setClearColor(new THREE.Color(0xeeeeee));\r\n  renderer.setSize(VIEWPORT_W, VIEWPORT_H);\r\n  renderer.shadowMap.enabled = true;\r\n\r\n  const ground = new THREE.PlaneGeometry(100, 100, 50, 50);\r\n  const groundMesh = createMultiMaterialObject(ground, [\r\n    new THREE.MeshBasicMaterial({\r\n      wireframe: true,\r\n      overdraw: 1,\r\n      color: 0x000000\r\n    }),\r\n    new THREE.MeshBasicMaterial({\r\n      color: 0x00ff00,\r\n      transparent: true,\r\n      opacity: 0.5\r\n    })\r\n  ]);\r\n  groundMesh.rotation.x = -0.5 * Math.PI;\r\n  scene.add(groundMesh);\r\n\r\n  const createMesh = (geom: THREE.Geometry) => {\r\n    const meshMaterial = new THREE.MeshNormalMaterial();\r\n    meshMaterial.side = THREE.DoubleSide;\r\n    const wireFrameMat = new THREE.MeshBasicMaterial();\r\n    wireFrameMat.wireframe = true;\r\n    return createMultiMaterialObject(geom, [meshMaterial, wireFrameMat]);\r\n  };\r\n\r\n  const setFromObject = (object: THREE.Group) => {\r\n    const box = new THREE.Box3();\r\n    const v1 = new THREE.Vector3();\r\n    object.updateMatrixWorld(true);\r\n    box.makeEmpty();\r\n    object.traverse((node: THREE.Mesh) => {\r\n      if (\r\n        node.geometry !== undefined &&\r\n        (node.geometry as THREE.Geometry).vertices !== undefined\r\n      ) {\r\n        const vertices = (node.geometry as THREE.Geometry).vertices;\r\n        for (let i = 0, il = vertices.length; i < il; i++) {\r\n          v1.copy(vertices[i]);\r\n          v1.applyMatrix4(node.matrixWorld);\r\n          box.expandByPoint(v1);\r\n        }\r\n      }\r\n    });\r\n    return box;\r\n  };\r\n\r\n  document.getElementById('WebGL-output').appendChild(renderer.domElement);\r\n\r\n  /* stats */\r\n  const initStats = () => {\r\n    const statsObj = new Stats();\r\n    statsObj.showPanel(0);\r\n    statsObj.dom.style.position = 'absolute';\r\n    statsObj.dom.style.left = '0px';\r\n    statsObj.dom.style.top = '0px';\r\n    document.getElementById('Stats-output').appendChild(statsObj.dom);\r\n    return statsObj;\r\n  };\r\n  const stats = initStats();\r\n\r\n  let sphere: THREE.Group;\r\n  let cube: THREE.Group;\r\n  let group: THREE.Group;\r\n  let bboxMesh: THREE.Mesh;\r\n\r\n  /* gui */\r\n  const controls = {\r\n    cubePosX: 0,\r\n    cubePosY: 3,\r\n    cubePosZ: 10,\r\n    spherePosX: 10,\r\n    spherePosY: 5,\r\n    spherePosZ: 0,\r\n    groupPosX: 10,\r\n    groupPosY: 5,\r\n    groupPosZ: 0,\r\n    grouping: false,\r\n    rotate: false,\r\n    groupScale: 1,\r\n    cubeScale: 1,\r\n    sphereScale: 1,\r\n    redraw: () => {\r\n      scene.remove(group);\r\n      sphere = createMesh(new THREE.SphereGeometry(5, 10, 10));\r\n      cube = createMesh(new THREE.BoxGeometry(6, 6, 6));\r\n      sphere.position.set(\r\n        controls.spherePosX,\r\n        controls.spherePosY,\r\n        controls.spherePosZ\r\n      );\r\n      cube.position.set(\r\n        controls.cubePosX,\r\n        controls.cubePosY,\r\n        controls.cubePosZ\r\n      );\r\n      group = new THREE.Group();\r\n      group.add(sphere);\r\n      group.add(cube);\r\n      scene.add(group);\r\n      controls.positionBoundingBox();\r\n      const arrow = new THREE.ArrowHelper(\r\n        new THREE.Vector3(0, 1, 0),\r\n        group.position,\r\n        10,\r\n        0x0000ff\r\n      );\r\n      scene.add(arrow);\r\n    },\r\n    positionBoundingBox: () => {\r\n      scene.remove(bboxMesh);\r\n      const box = setFromObject(group);\r\n      const width = box.max.x - box.min.x;\r\n      const height = box.max.y - box.min.y;\r\n      const depth = box.max.z - box.min.z;\r\n      const bbox = new THREE.BoxGeometry(width, height, depth);\r\n      bboxMesh = new THREE.Mesh(\r\n        bbox,\r\n        new THREE.MeshBasicMaterial({\r\n          color: 0x000000,\r\n          vertexColors: THREE.VertexColors,\r\n          wireframeLinewidth: 2,\r\n          wireframe: true\r\n        })\r\n      );\r\n      bboxMesh.position.x = (box.min.x + box.max.x) / 2;\r\n      bboxMesh.position.y = (box.min.y + box.max.y) / 2;\r\n      bboxMesh.position.z = (box.min.z + box.max.z) / 2;\r\n    }\r\n  };\r\n\r\n  const gui = new dat.GUI();\r\n  const sphereFolder = gui.addFolder('sphere');\r\n  sphereFolder.add(controls, 'spherePosX', -20, 20).onChange((e: number) => {\r\n    sphere.position.x = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  sphereFolder.add(controls, 'spherePosZ', -20, 20).onChange((e: number) => {\r\n    sphere.position.z = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  sphereFolder.add(controls, 'spherePosY', -20, 20).onChange((e: number) => {\r\n    sphere.position.y = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  sphereFolder.add(controls, 'sphereScale', 0, 3).onChange((e: number) => {\r\n    sphere.scale.set(e, e, e);\r\n    controls.positionBoundingBox();\r\n  });\r\n\r\n  const cubeFolder = gui.addFolder('cube');\r\n  cubeFolder.add(controls, 'cubePosX', -20, 20).onChange((e: number) => {\r\n    cube.position.x = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  cubeFolder.add(controls, 'cubePosZ', -20, 20).onChange((e: number) => {\r\n    cube.position.z = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  cubeFolder.add(controls, 'cubePosY', -20, 20).onChange((e: number) => {\r\n    cube.position.y = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  cubeFolder.add(controls, 'cubeScale', 0, 3).onChange((e: number) => {\r\n    cube.scale.set(e, e, e);\r\n    controls.positionBoundingBox();\r\n  });\r\n\r\n  const groupFolder = gui.addFolder('group');\r\n  groupFolder.add(controls, 'groupPosX', -20, 20).onChange((e: number) => {\r\n    group.position.x = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  groupFolder.add(controls, 'groupPosZ', -20, 20).onChange((e: number) => {\r\n    group.position.z = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  groupFolder.add(controls, 'groupPosY', -20, 20).onChange((e: number) => {\r\n    group.position.y = e;\r\n    controls.positionBoundingBox();\r\n  });\r\n  groupFolder.add(controls, 'groupScale', 0, 3).onChange((e: number) => {\r\n    group.scale.set(e, e, e);\r\n    controls.positionBoundingBox();\r\n  });\r\n  gui.add(controls, 'grouping');\r\n  gui.add(controls, 'rotate');\r\n\r\n  /* resize */\r\n  window.addEventListener(\r\n    'resize',\r\n    () => {\r\n      camera.aspect = window.innerWidth / window.innerHeight;\r\n      camera.updateProjectionMatrix();\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n    },\r\n    false\r\n  );\r\n\r\n  /* render */\r\n  let step = 0.03;\r\n  const renderScene = () => {\r\n    stats.update();\r\n\r\n    if (controls.grouping && controls.rotate) {\r\n      group.rotation.y += step;\r\n    }\r\n    if (controls.rotate && !controls.grouping) {\r\n      sphere.rotation.y += step;\r\n      cube.rotation.y += step;\r\n    }\r\n\r\n    requestAnimationFrame(renderScene);\r\n    renderer.render(scene, camera);\r\n  };\r\n  controls.redraw();\r\n  renderScene();\r\n};\r\n"],"mappings":"AAAA","sourceRoot":""}