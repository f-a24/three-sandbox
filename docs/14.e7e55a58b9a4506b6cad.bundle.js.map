{"version":3,"file":"14.e7e55a58b9a4506b6cad.bundle.js","sources":["webpack:///./src/appendix-A/1.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport 'imports-loader?THREE=three!../../node_modules/three/examples/js/vr/WebVR.js';\r\nimport createMultiMaterialObject from '../utils/createMultiMaterialObject';\r\n\r\nexport default () => {\r\n  // 画面サイズ\r\n  const VIEWPORT_W = window.innerWidth;\r\n  const VIEWPORT_H = window.innerHeight;\r\n\r\n  /* scene */\r\n  const scene = new THREE.Scene();\r\n\r\n  /* camera */\r\n  const camera = new THREE.PerspectiveCamera(\r\n    45,\r\n    window.innerWidth / window.innerHeight,\r\n    0.1,\r\n    1000\r\n  );\r\n  camera.position.x = 8;\r\n  camera.lookAt(new THREE.Vector3(0, 0, 0));\r\n\r\n  /* renderer */\r\n  const renderer = new THREE.WebGLRenderer();\r\n  renderer.setClearColor(new THREE.Color(0x000000));\r\n  renderer.setSize(VIEWPORT_W, VIEWPORT_H);\r\n  // renderer.vr.enabled = true;\r\n\r\n  const raycaster = new THREE.Raycaster();\r\n  var selectedDebri;\r\n\r\n  const createEarthMesh = (geom: THREE.Geometry) => {\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const planetTexture = textureLoader.load('./assets/Earth.png');\r\n    const specularTexture = textureLoader.load('./assets/EarthSpec.png');\r\n    const normalTexture = textureLoader.load('./assets/EarthNormal.png');\r\n    const planetMaterial = new THREE.MeshPhongMaterial();\r\n    planetMaterial.specularMap = specularTexture;\r\n    planetMaterial.specular = new THREE.Color(0x4444aa);\r\n    planetMaterial.shininess = 5;\r\n    planetMaterial.normalMap = normalTexture;\r\n    planetMaterial.normalScale = new THREE.Vector2(5, 5);\r\n    planetMaterial.map = planetTexture;\r\n    return createMultiMaterialObject(geom, [planetMaterial]);\r\n  };\r\n\r\n  const createAirMesh = (geom: THREE.Geometry) => {\r\n    const planetMaterial = new THREE.MeshPhongMaterial();\r\n    planetMaterial.side = THREE.BackSide;\r\n    planetMaterial.transparent = true;\r\n    planetMaterial.opacity = 0.2;\r\n    planetMaterial.color = new THREE.Color(0xffffff);\r\n    return createMultiMaterialObject(geom, [planetMaterial]);\r\n  };\r\n\r\n  const createMoonMesh = (geom: THREE.Geometry) => {\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const planetTexture = textureLoader.load('./assets/Moon.png');\r\n    const normalTexture = textureLoader.load('./assets/Mars-normalmap_2k.png');\r\n    const planetMaterial = new THREE.MeshPhongMaterial();\r\n    planetMaterial.normalMap = normalTexture;\r\n    planetMaterial.normalScale = new THREE.Vector2(5, 5);\r\n    planetMaterial.map = planetTexture;\r\n    planetMaterial.specularMap = planetTexture;\r\n    planetMaterial.specular = new THREE.Color(0x444400);\r\n    planetMaterial.shininess = 0;\r\n    return new THREE.Mesh(geom, planetMaterial);\r\n  };\r\n\r\n  const createStarPoints = (\r\n    num: number,\r\n    size: number,\r\n    center: THREE.Vector3,\r\n    radius: number,\r\n    red?: boolean\r\n  ) => {\r\n    const geom = new THREE.Geometry();\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const texture = textureLoader.load(\r\n      red ? './assets/lensflare0.png' : './assets/lensflare0_white.png'\r\n    );\r\n    const material = new THREE.PointsMaterial({ size: size, map: texture });\r\n    for (let i = 0; i < num; i++) {\r\n      const theta = Math.random() * 2 * Math.PI;\r\n      const phi = Math.random() * 2 * Math.PI;\r\n      const r = radius * (1.5 + Math.random() / 10);\r\n      const particle = new THREE.Vector3(\r\n        r * Math.sin(theta) * Math.cos(phi),\r\n        r * Math.sin(theta) * Math.sin(phi),\r\n        r * Math.cos(theta)\r\n      );\r\n      geom.vertices.push(particle);\r\n    }\r\n    return new THREE.Points(geom, material);\r\n  };\r\n\r\n  const putDebriRandom = (\r\n    mesh: THREE.Mesh,\r\n    limitRadius: number,\r\n    center: THREE.Vector3\r\n  ) => {\r\n    const theta = Math.random() * 2 * Math.PI;\r\n    const phi = Math.random() * 2 * Math.PI;\r\n    const r = limitRadius * 2 + Math.random() / 100;\r\n    mesh.position.set(\r\n      center.x + r * Math.sin(theta) * Math.cos(phi),\r\n      center.y + r * Math.sin(theta) * Math.sin(phi),\r\n      center.z + r * Math.cos(theta)\r\n    );\r\n  };\r\n\r\n  const createDebri = (limitRadius: number, center: THREE.Vector3) => {\r\n    const geom = new THREE.BoxGeometry(1, 1, 1);\r\n    const material = new THREE.MeshPhongMaterial();\r\n    material.color = new THREE.Color(Math.random() * 0xffffff);\r\n    material.emissive = new THREE.Color(0x333333);\r\n    material.specular = new THREE.Color(0x4444aa);\r\n    material.shininess = 100;\r\n    const mesh = new THREE.Mesh(geom, material);\r\n    putDebriRandom(mesh, limitRadius, center);\r\n    mesh.rotation.x = Math.random() * 2 * Math.PI;\r\n    mesh.rotation.y = Math.random() * 2 * Math.PI;\r\n    mesh.rotation.z = Math.random() * 2 * Math.PI;\r\n    (mesh as any).drotx = (Math.random() - 0.5) / 10;\r\n    (mesh as any).droty = (Math.random() - 0.5) / 10;\r\n    (mesh as any).drotz = (Math.random() - 0.5) / 10;\r\n    return mesh;\r\n  };\r\n\r\n  const removeSelectedDebri = (limitRadius, center) => {\r\n    if (selectedDebri) {\r\n      putDebriRandom(selectedDebri, limitRadius, center);\r\n      deselectDebri();\r\n    }\r\n  };\r\n\r\n  const deselectDebri = () => {\r\n    if (selectedDebri) {\r\n      selectedDebri.material.emissive.setHex(0x333333);\r\n      selectedDebri.scale.set(1, 1, 1);\r\n    }\r\n    selectedDebri = null;\r\n  };\r\n\r\n  const selectDebri = () => {\r\n    raycaster.setFromCamera({ x: 0, y: 0 }, camera);\r\n    const intersects = raycaster.intersectObjects(earthAndDebris);\r\n    if (intersects.length === 0) {\r\n      deselectDebri();\r\n    } else {\r\n      for (let i = 0; i < intersects.length; i++) {\r\n        const debri = intersects[i].object;\r\n        if (debri === earth) {\r\n          console.log(debri === earth);\r\n          break;\r\n        }\r\n        if (selectedDebri !== debri) {\r\n          deselectDebri();\r\n          selectedDebri = debri;\r\n          (debri as any).material.emissive.setHex(0xff3333);\r\n          debri.scale.set(2, 2, 2);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /* earth */\r\n  const earth = createEarthMesh(new THREE.SphereGeometry(10, 80, 80));\r\n  earth.position.y = -10;\r\n  scene.add(earth);\r\n\r\n  /* air */\r\n  const air = createAirMesh(new THREE.SphereGeometry(10.1, 80, 80));\r\n  air.position.copy(earth.position);\r\n  scene.add(air);\r\n\r\n  /* moon */\r\n  const moon = createMoonMesh(new THREE.SphereGeometry(5, 20, 20));\r\n  moon.position.x = -50;\r\n  earth.add(moon);\r\n\r\n  /* stars */\r\n  const pos = earth.position;\r\n  const rad = Math.abs(moon.position.x);\r\n  earth.add(createStarPoints(100, 5, pos, rad, true));\r\n  earth.add(createStarPoints(500, 3, pos, rad));\r\n  earth.add(createStarPoints(2000, 2, pos, rad));\r\n\r\n  /* debris */\r\n  const earthAndDebris = [earth];\r\n  const debris = [];\r\n  for (let i = 0; i < 30; i++) {\r\n    const debri = createDebri(10.2, earth.position);\r\n    earth.add(debri);\r\n    debris.push(debri);\r\n    const earthGroup = new THREE.Group();\r\n    earthGroup.add(debri);\r\n    earthAndDebris.push(earthGroup);\r\n  }\r\n\r\n  const ambi = new THREE.AmbientLight(0x181818);\r\n  scene.add(ambi);\r\n\r\n  const directionalLight = new THREE.DirectionalLight(0xffffff);\r\n  directionalLight.position.set(100, 0, 150);\r\n  earth.add(directionalLight);\r\n\r\n  const directionalBackLight = new THREE.DirectionalLight(0xffffff);\r\n  directionalBackLight.position.copy(\r\n    directionalLight.position.clone().negate()\r\n  );\r\n  directionalBackLight.intensity = 0.7;\r\n  earth.add(directionalBackLight);\r\n\r\n  document.getElementById('WebGL-output').appendChild(renderer.domElement);\r\n\r\n  renderer.domElement.addEventListener(\r\n    'click',\r\n    function() {\r\n      if (\r\n        !(document as any).mozFullScreen &&\r\n        !(document as any).webkitIsFullScreen\r\n      ) {\r\n        const canvas = renderer.domElement;\r\n        const requestFullScreen =\r\n          (canvas as any).mozRequestFullScreen ||\r\n          (canvas as any).webkitRequestFullScreen;\r\n        requestFullScreen.bind(canvas)();\r\n      } else {\r\n        removeSelectedDebri(10.2, earth.position);\r\n      }\r\n    }.bind(this)\r\n  );\r\n\r\n  /* resize */\r\n  window.addEventListener(\r\n    'resize',\r\n    () => {\r\n      camera.aspect = window.innerWidth / window.innerHeight;\r\n      camera.updateProjectionMatrix();\r\n      renderer.setSize(window.innerWidth, window.innerHeight);\r\n    },\r\n    false\r\n  );\r\n\r\n  /* render */\r\n  const renderScene = () => {\r\n    debris.forEach(function(debri) {\r\n      debri.rotation.x += debri.drotx;\r\n      debri.rotation.y += debri.droty;\r\n      debri.rotation.z += debri.drotz;\r\n    });\r\n    selectDebri();\r\n    earth.rotation.z -= 0.001;\r\n    // render using requestAnimationFrame\r\n    requestAnimationFrame(renderScene);\r\n  };\r\n  renderScene();\r\n};\r\n"],"mappings":"AAAA","sourceRoot":""}