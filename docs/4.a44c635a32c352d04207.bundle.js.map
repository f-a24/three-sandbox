{"version":3,"file":"4.a44c635a32c352d04207.bundle.js","sources":["webpack:///./src/utils/Lensflare.ts"],"sourcesContent":["import * as THREE from 'three';\n\nconst material1aVert = require('./material1a.vert');\nconst material1aFrag = require('./material1a.frag');\nconst material1bVert = require('./material1b.vert');\nconst material1bFrag = require('./material1b.frag');\nconst elementVert = require('./element.vert');\nconst elementFrag = require('./element.frag');\n\nconst Lensflare = function() {\n  THREE.Mesh.call(\n    this,\n    Lensflare.Geometry,\n    new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })\n  );\n\n  this.type = 'Lensflare';\n  this.frustumCulled = false;\n  this.renderOrder = Infinity;\n\n  //\n\n  const positionScreen = new THREE.Vector3();\n  const positionView = new THREE.Vector3();\n\n  // textures\n\n  const tempMap = new THREE.DataTexture(\n    new Uint8Array(16 * 16 * 3),\n    16,\n    16,\n    THREE.RGBFormat\n  );\n  tempMap.minFilter = THREE.NearestFilter;\n  tempMap.magFilter = THREE.NearestFilter;\n  tempMap.wrapS = THREE.ClampToEdgeWrapping;\n  tempMap.wrapT = THREE.ClampToEdgeWrapping;\n  tempMap.needsUpdate = true;\n\n  const occlusionMap = new THREE.DataTexture(\n    new Uint8Array(16 * 16 * 3),\n    16,\n    16,\n    THREE.RGBFormat\n  );\n  occlusionMap.minFilter = THREE.NearestFilter;\n  occlusionMap.magFilter = THREE.NearestFilter;\n  occlusionMap.wrapS = THREE.ClampToEdgeWrapping;\n  occlusionMap.wrapT = THREE.ClampToEdgeWrapping;\n  occlusionMap.needsUpdate = true;\n\n  // material\n\n  const geometry = Lensflare.Geometry;\n\n  const material1a = new THREE.RawShaderMaterial({\n    uniforms: {\n      scale: { value: null },\n      screenPosition: { value: null }\n    },\n    vertexShader: material1aVert.default,\n    fragmentShader: material1aFrag.default,\n    depthTest: true,\n    depthWrite: false,\n    transparent: false\n  });\n\n  const material1b = new THREE.RawShaderMaterial({\n    uniforms: {\n      map: { value: tempMap },\n      scale: { value: null },\n      screenPosition: { value: null }\n    },\n    vertexShader: material1bVert.default,\n    fragmentShader: material1bFrag.default,\n    depthTest: false,\n    depthWrite: false,\n    transparent: false\n  });\n\n  // the following object is used for occlusionMap generation\n\n  const mesh1 = new THREE.Mesh(geometry, material1a);\n\n  //\n\n  const elements = [];\n\n  const shader = LensflareElement.Shader;\n\n  const material2 = new THREE.RawShaderMaterial({\n    uniforms: {\n      map: { value: null },\n      occlusionMap: { value: occlusionMap },\n      color: { value: new THREE.Color(0xffffff) },\n      scale: { value: new THREE.Vector2() },\n      screenPosition: { value: new THREE.Vector3() }\n    },\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    blending: THREE.AdditiveBlending,\n    transparent: true,\n    depthWrite: false\n  });\n\n  const mesh2 = new THREE.Mesh(geometry, material2);\n\n  this.addElement = function(element) {\n    elements.push(element);\n  };\n\n  //\n\n  const scale = new THREE.Vector2();\n  const screenPositionPixels = new THREE.Vector2();\n  const validArea = new THREE.Box2();\n  const viewport = new THREE.Vector4();\n\n  this.onBeforeRender = function(renderer, scene, camera) {\n    renderer.getCurrentViewport(viewport);\n\n    const invAspect = viewport.w / viewport.z;\n    const halfViewportWidth = viewport.z / 2.0;\n    const halfViewportHeight = viewport.w / 2.0;\n\n    const size = 16 / viewport.w;\n    scale.set(size * invAspect, size);\n\n    validArea.min.set(viewport.x, viewport.y);\n    validArea.max.set(\n      viewport.x + (viewport.z - 16),\n      viewport.y + (viewport.w - 16)\n    );\n\n    // calculate position in screen space\n\n    positionView.setFromMatrixPosition(this.matrixWorld);\n    positionView.applyMatrix4(camera.matrixWorldInverse);\n\n    if (positionView.z > 0) return; // lensflare is behind the camera\n\n    positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n\n    // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n    screenPositionPixels.x =\n      viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n    screenPositionPixels.y =\n      viewport.y +\n      positionScreen.y * halfViewportHeight +\n      halfViewportHeight -\n      8;\n\n    // screen cull\n\n    if (validArea.containsPoint(screenPositionPixels)) {\n      // save current RGB to temp texture\n\n      renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n\n      // render pink quad\n\n      const uniforms = material1a.uniforms;\n      uniforms['scale'].value = scale;\n      uniforms['screenPosition'].value = positionScreen;\n\n      renderer.renderBufferDirect(\n        camera,\n        null,\n        geometry,\n        material1a,\n        mesh1,\n        null\n      );\n\n      // copy result to occlusionMap\n\n      renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n\n      // restore graphics\n\n      // const uniforms = material1b.uniforms;\n      // uniforms['scale'].value = scale;\n      // uniforms['screenPosition'].value = positionScreen;\n\n      renderer.renderBufferDirect(\n        camera,\n        null,\n        geometry,\n        material1b,\n        mesh1,\n        null\n      );\n\n      // render elements\n\n      const vecX = -positionScreen.x * 2;\n      const vecY = -positionScreen.y * 2;\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        const element = elements[i];\n\n        const uniforms = material2.uniforms;\n\n        uniforms['color'].value.copy(element.color);\n        uniforms['map'].value = element.texture;\n        uniforms['screenPosition'].value.x =\n          positionScreen.x + vecX * element.distance;\n        uniforms['screenPosition'].value.y =\n          positionScreen.y + vecY * element.distance;\n\n        const size = element.size / viewport.w;\n        const invAspect = viewport.w / viewport.z;\n\n        uniforms['scale'].value.set(size * invAspect, size);\n\n        // material2.uniformsNeedUpdate = true;\n\n        renderer.renderBufferDirect(\n          camera,\n          null,\n          geometry,\n          material2,\n          mesh2,\n          null\n        );\n      }\n    }\n  };\n\n  this.dispose = function() {\n    material1a.dispose();\n    material1b.dispose();\n    material2.dispose();\n\n    tempMap.dispose();\n    occlusionMap.dispose();\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      elements[i].texture.dispose();\n    }\n  };\n};\n\nLensflare.prototype = Object.create(THREE.Mesh.prototype);\nLensflare.prototype.constructor = Lensflare;\nLensflare.prototype.isLensflare = true;\n\n//\n\nconst LensflareElement = function(\n  texture: THREE.Texture,\n  size?: number,\n  distance?: number,\n  color?: THREE.Color\n) {\n  this.texture = texture;\n  this.size = size || 1;\n  this.distance = distance || 0;\n  this.color = color || new THREE.Color(0xffffff);\n};\n\nLensflareElement.Shader = {\n  uniforms: {\n    map: { value: null },\n    occlusionMap: { value: null },\n    color: { value: null },\n    scale: { value: null },\n    screenPosition: { value: null }\n  },\n  vertexShader: elementVert.default,\n  fragmentShader: elementFrag.default\n};\n\nLensflare.Geometry = (function() {\n  const geometry = new THREE.BufferGeometry();\n\n  const float32Array = new Float32Array([\n    -1,\n    -1,\n    0,\n    0,\n    0,\n    1,\n    -1,\n    0,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    -1,\n    1,\n    0,\n    0,\n    1\n  ]);\n\n  const interleavedBuffer = new THREE.InterleavedBuffer(float32Array, 5);\n\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.addAttribute(\n    'position',\n    new THREE.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false)\n  );\n  geometry.addAttribute(\n    'uv',\n    new THREE.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false)\n  );\n\n  return geometry;\n})();\n\nexport { Lensflare, LensflareElement };\n"],"mappings":"AAEA","sourceRoot":""}